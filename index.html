<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-touch-fullscreen" content="yes">
<title>Ocean's Edge - Crash Counter Edition</title>
<style>
/* ---------- Base & Layout ---------- */
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html, body { width: 100%; height: 100%; overflow: hidden; position: fixed; -webkit-overflow-scrolling: touch; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
body{font-family:-apple-system,BlinkMacSystemFont,system-ui,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial; background:#001122;overflow:hidden;height:100vh;user-select:none;touch-action:none; -webkit-touch-callout:none;-webkit-user-select:none}
#gameContainer{position:relative;width:100vw;height:100vh;overflow:hidden}
#gameCanvas{display:block;width:100%;height:100%;object-fit:cover;touch-action:none;image-rendering:pixelated;image-rendering:-moz-crisp-edges;image-rendering:crisp-edges}

/* ---------- Decorative Waves ---------- */
.ocean-waves,.floating-waves{position:absolute;inset:0;pointer-events:none}
.ocean-waves{ background: radial-gradient(circle at 20% 80%, rgba(135,206,235,.25) 0%, transparent 50%), radial-gradient(circle at 80% 20%, rgba(70,130,180,.18) 0%, transparent 50%), radial-gradient(circle at 40% 40%, rgba(25,25,112,.08) 0%, transparent 50%); animation:oceanWaves 6s ease-in-out infinite; z-index:1 }
@keyframes oceanWaves{0%,100%{transform:translateY(0) scale(1);opacity:.65} 50%{transform:translateY(-15px) scale(1.02);opacity:.95}}
.floating-waves{ background:linear-gradient(90deg,transparent 0%, rgba(255,255,255,.08) 50%, transparent 100%); animation:floatingWaves 8s linear infinite; z-index:2 }
@keyframes floatingWaves{0%{transform:translateX(-100%)}100%{transform:translateX(100%)}}

/* ---------- HUD ---------- */
#hud{position:absolute;top:0;left:0;right:70px;z-index:5;color:#fff;padding:8px 12px;display:none;flex-direction:column;align-items:flex-start;gap:8px;font-weight:600;font-size:14px;background:transparent;border:none;width:auto;max-width:400px}
.hud-row{display:flex;flex-direction:row;align-items:center;gap:20px}
.hud-stat{display:flex;align-items:center;gap:8px;min-width:0;flex-shrink:0}
.hud-label{font-size:14px;opacity:.8;font-weight:500;white-space:nowrap}
.hud-value{font-size:16px;font-weight:600;text-shadow:1px 1px 2px rgba(0,0,0,0.5);white-space:nowrap}

.progress-mini{width:80px;height:6px;border-radius:3px;overflow:hidden;background:rgba(0,0,0,.4);position:relative;border:1px solid rgba(255,255,255,.3);box-shadow:none;flex-shrink:0}
.hull-fill{height:100%;background:linear-gradient(90deg,#ff4444,#44ff44);transition:width .4s ease, background .4s ease;border-radius:3px;box-shadow:none}
.fuel-fill{height:100%;background:linear-gradient(90deg,#ff8800,#ffdd00);transition:width .4s ease, background .4s ease;border-radius:3px;box-shadow:none}

.season-indicator{display:inline-block;font-weight:700;font-size:14px;padding:6px 12px;border-radius:20px;transition:all 0.5s ease;white-space:nowrap;flex-shrink:0;margin-top:4px}
.winter{background:rgba(255,235,59,0.9);color:#333}
.summer{background:rgba(255,235,59,0.9);color:#333}
.monsoon{background:rgba(255,235,59,0.9);color:#333}
.storm{background:rgba(255,255,255,0.9);color:#ff0000 !important}

/* ---------- Buttons & Pause ---------- */
.pause-btn{position:absolute;top:10px;right:10px;z-index:6;background:rgba(0,20,40,.9);color:#fff;padding:8px 12px;border-radius:8px;border:2px solid rgba(135,206,235,.4);cursor:pointer;font-size:14px;font-weight:600;transition:all .2s ease;-webkit-tap-highlight-color:transparent;touch-action:manipulation;display:none}
.pause-btn:hover{background:rgba(70,130,180,.8);transform:translateY(-1px)}
.pause-btn:active{transform:translateY(0)}

.performance-indicator{position:absolute;top:10px;left:10px;z-index:6;background:rgba(0,20,40,.7);color:#fff;padding:4px 8px;border-radius:4px;font-size:12px;font-weight:500;display:none}
.fps-good{color:#4CAF50} .fps-ok{color:#FFC107} .fps-bad{color:#F44336}

/* ---------- Screens ---------- */
#menuScreen,#gameOverScreen,#pauseScreen{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;color:#fff;text-align:center;z-index:6}
#menuScreen{background:linear-gradient(180deg,#001122 0%,#003366 50%,#004488 100%)}
#gameOverScreen,#pauseScreen{display:none;background:rgba(0,17,34,.95);backdrop-filter:blur(10px)}

.pause-buttons{display:flex;flex-direction:column;gap:12px;margin-top:18px;align-items:center;justify-content:center;flex-wrap:nowrap;width:100%}

.title{font-size:4rem;font-weight:900;color:#87CEEB;text-shadow:3px 3px 6px rgba(0,0,0,.8);margin-bottom:14px}
.subtitle{max-width:700px;color:#B0C4DE;line-height:1.6;margin:0 20px 36px}
.game-btn{background:linear-gradient(45deg,#9b59b6,#6bb6ff);color:#fff;border:0;padding:14px 28px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(155,89,182,.35);transition:transform .15s ease, box-shadow .15s ease;margin:5px;-webkit-tap-highlight-color:transparent;touch-action:manipulation;-webkit-appearance:none;appearance:none;min-width:240px}
.game-btn:hover{transform:translateY(-2px);box-shadow:0 10px 26px rgba(155,89,182,.45)}
.game-btn:active{transform:translateY(0)}
.controls{margin-top:22px;color:#B0C4DE}

/* ---------- Sensitivity Control ---------- */
.sensitivity-control{display:none;flex-direction:column;align-items:center;background:rgba(0,20,40,.9);padding:18px;border-radius:12px;border:2px solid rgba(135,206,235,.4);margin:10px 0;min-width:260px;max-width:420px}
.sensitivity-label{color:#87CEEB;font-size:16px;font-weight:600;margin-bottom:12px}
.slider-container{position:relative;width:200px;height:8px;background:rgba(255,255,255,.2);border-radius:4px;cursor:pointer}
.slider-track{width:100%;height:100%;border-radius:4px;background:linear-gradient(90deg,#9b59b6,#6bb6ff)}
.slider-knob{position:absolute;width:20px;height:20px;background:linear-gradient(45deg,#9b59b6,#6bb6ff);border-radius:50%;top:-6px;cursor:pointer;transition:transform 0.1s ease;box-shadow:0 2px 8px rgba(0,0,0,.3)}
.slider-knob:hover{transform:scale(1.1)}
.sensitivity-value{color:#B0C4DE;font-size:14px;margin-top:10px}

/* ---------- Effects ---------- */
.shake{animation:shake .28s ease-in-out}
@keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}

.combo-indicator{position:absolute;top:150px;right:20px;z-index:5;background:rgba(255,215,0,.2);color:#ffd700;padding:10px 15px;border-radius:10px;border:2px solid rgba(255,215,0,.5);backdrop-filter:blur(10px);font-weight:bold;font-size:14px;display:none;animation:pulse 1s infinite}
@keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.05)}}

.season-transition{position:absolute;inset:0;z-index:4;pointer-events:none;background:radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);opacity:0;animation:seasonFlash 1s ease-out}
@keyframes seasonFlash{0%{opacity:0}30%{opacity:1}100%{opacity:0}}

.mobile-touch-area{position:absolute;z-index:3;user-select:none;touch-action:none;opacity:0;-webkit-tap-highlight-color:transparent;display:none}

.virtual-joystick{position:absolute;z-index:4;pointer-events:none;display:none;width:120px;height:120px}
.joystick-base{position:absolute;width:100%;height:100%;border-radius:50%;background:rgba(255,255,255,0.15);border:3px solid rgba(255,255,255,0.3);backdrop-filter:blur(8px);box-shadow:0 4px 20px rgba(0,0,0,0.2)}
.joystick-knob{position:absolute;width:50px;height:50px;border-radius:50%;background:linear-gradient(135deg, rgba(255,255,255,0.8), rgba(255,255,255,0.4));border:2px solid rgba(255,255,255,0.6);box-shadow:0 2px 10px rgba(0,0,0,0.3), inset 0 1px 3px rgba(255,255,255,0.5);transition:all 0.1s ease;transform:translate(-50%, -50%)}

.fallback-message{position:absolute;inset:0;display:none;flex-direction:column;align-items:center;justify-content:center;background:#001122;color:#fff;text-align:center;padding:20px;z-index:10}
.fallback-message h2{color:#ff6b6b;margin-bottom:20px}

.critical-warning{animation:criticalPulse 0.8s ease-in-out infinite alternate}
@keyframes criticalPulse{0%{background:rgba(255,0,0,0.3)}100%{background:rgba(255,100,100,0.6)}}

.pause-sensitivity-wrapper{display:flex;flex-direction:column;align-items:center;width:100%}
.pause-sensitivity-wrapper .sensitivity-control{min-width:260px;max-width:420px}

/* Responsive */
@media (max-width: 768px) {
.title{font-size:2.5rem}
.subtitle{font-size:14px}
.pause-btn{padding:12px 16px}
#hud{padding:6px 8px;right:60px}
.hud-row{gap:15px}
.hud-label{font-size:13px}
.hud-value{font-size:15px}
.season-indicator{font-size:13px;padding:5px 10px}
.pause-buttons{flex-direction:column;gap:10px}
.virtual-joystick{width:100px;height:100px}
.joystick-knob{width:40px;height:40px}
.sensitivity-control{min-width:280px}
}

@media screen and (max-width: 480px) {
.title{font-size:2rem}
#hud{padding:4px 6px;right:55px}
.hud-row{gap:12px}
.hud-label{font-size:12px}
.hud-value{font-size:14px}
.season-indicator{font-size:12px;padding:4px 8px}
.progress-mini{width:60px}
.pause-buttons{flex-direction:column;gap:8px}
.game-btn{padding:12px 24px;font-size:14px}
.virtual-joystick{width:90px;height:90px}
.joystick-knob{width:35px;height:35px}
.sensitivity-control{min-width:260px}
.slider-container{width:180px}
}
</style>
</head>
<body>
<div id="gameContainer">
  <div class="ocean-waves"></div>
  <div class="floating-waves"></div>

  <!-- MAIN MENU -->
  <div id="menuScreen">
    <h1 class="title">Ocean's Edge</h1>
    <p class="subtitle">
      Navigate treacherous waters in your sailing ship. Collect fuel and repair kits while avoiding enemy ships. See how many crashes you can survive in these pirate-infested waters!
    </p>
    <button class="game-btn" onclick="GameManager.startGame()">Set Sail</button>

    <div class="controls">Use WASD or Arrow keys to move • SPACE to pause<br><small>Touch and drag virtual joystick on mobile</small></div>
  </div>

  <!-- GAME CANVAS -->
  <canvas id="gameCanvas" style="display:none"></canvas>

  <!-- HUD -->
  <div id="hud">
    <div class="hud-row">
      <div class="hud-stat">
        <span class="hud-label">Distance</span>
        <span class="hud-value" id="distance">0km</span>
      </div>

      <div class="hud-stat">
        <span class="hud-label">Health</span>
        <div class="progress-mini">
          <div id="hullBar" class="hull-fill" style="width:100%"></div>
        </div>
        <span class="hud-value" id="hullPercent">100%</span>
      </div>
    </div>

    <div class="hud-row">
      <div class="hud-stat">
        <span class="hud-label">Crashes</span>
        <span class="hud-value" id="crashes">0</span>
      </div>

      <div class="hud-stat">
        <span class="hud-label">Fuel</span>
        <div class="progress-mini">
          <div id="fuelBar" class="fuel-fill" style="width:100%"></div>
        </div>
        <span class="hud-value" id="fuelPercent">100%</span>
      </div>
    </div>

    <div id="season" class="season-indicator winter">Winter</div>
  </div>

  <!-- Mobile touch area and joystick -->
  <div class="mobile-touch-area" id="mobileArea" style="position:absolute;top:0;left:0;width:100%;height:100%;z-index:3"></div>

  <div class="virtual-joystick" id="virtualJoystick">
    <div class="joystick-base"></div>
    <div class="joystick-knob" id="joystickKnob"></div>
  </div>

  <!-- Pause button & indicators -->
  <div class="pause-btn" id="pauseBtn" onclick="GameManager.togglePause()">☰</div>
  <div class="performance-indicator" id="performanceIndicator">FPS: <span id="fpsDisplay">60</span></div>

  <div class="combo-indicator" id="comboIndicator">
    <div>COMBO x<span id="comboCount">2</span></div>
    <div style="font-size:12px">+<span id="comboBonus">100</span> bonus!</div>
  </div>

  <!-- PAUSE SCREEN -->
  <div id="pauseScreen">
    <h2 class="title" style="font-size:3rem">Paused</h2>
    <div class="pause-buttons">
      <button class="game-btn" onclick="GameManager.togglePause()">Resume</button>
      <button class="game-btn" onclick="GameManager.restartGame()">Restart</button>

      <div class="pause-sensitivity-wrapper">
        <button class="game-btn" id="pauseSensitivityBtn" onclick="GameManager.togglePauseSensitivity()">Sensitivity</button>
        <div class="sensitivity-control" id="sensitivityControl">
          <div class="sensitivity-label">Ship Movement Sensitivity</div>
          <div class="slider-container" id="sliderContainer">
            <div class="slider-track"></div>
            <div class="slider-knob" id="sliderKnob"></div>
          </div>
          <div class="sensitivity-value" id="sensitivityValue">Normal (1.0x)</div>
        </div>
      </div>

      <button class="game-btn" onclick="GameManager.returnToMenu()">Exit</button>
    </div>
  </div>

  <!-- GAME OVER SCREEN -->
  <div id="gameOverScreen">
    <h2 class="title" style="font-size:3rem;color:#ff6b6b">Game Over</h2>
    <p style="margin:8px 0">Distance Sailed: <b id="finalDistance">0 km</b></p>
    <p style="margin:8px 0">Total Crashes: <b id="finalCrashes">0</b></p>
    <p style="margin:8px 0">Season Reached: <b id="finalSeason">Winter</b></p>
    <div style="display:flex;gap:10px;margin-top:18px">
      <button class="game-btn" onclick="GameManager.restartGame()">Play Again</button>
      <button class="game-btn" onclick="GameManager.returnToMenu()">Main Menu</button>
    </div>
  </div>

  <div class="fallback-message" id="fallbackMessage">
    <h2>Browser Not Supported</h2>
    <p>This game requires Canvas and modern JavaScript features.<br> Please update your browser or try a different one.</p>
  </div>
</div>

<script>
// iOS Compatibility Check
const iOSCheck = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

// CONFIG
const CONFIG = {
  GAME: {
    TARGET_FPS: 60,
    PHYSICS_TIMESTEP: 1/60,
    MAX_DELTA_TIME: 0.05,
    MIN_DELTA_TIME: 0.0001,
    DEBUG_MODE: false
  },
  CANVAS: {
    MAX_DEVICE_PIXEL_RATIO: 2,
    MIN_WIDTH: 320,
    MIN_HEIGHT: 480,
    ENABLE_ANTIALIASING: true
  },
  PLAYER: {
    SPEED: 5,
    SENSITIVITY: 1.0,
    WIDTH: 36,
    HEIGHT: 56,
    HULL_DECAY_RATE: 0.6,
    FUEL_CONSUMPTION_RATE: 1.0,
    SAILS_WEAR_RATE: 0.3,
    MIN_EFFICIENCY: 0.3,
    SIDE_MARGIN: 10,
    TOP_MARGIN: 10,
    BOTTOM_MARGIN: 30,
    WAKE_TRAIL_LENGTH: 15,
    BOB_AMPLITUDE: 3,
    BOB_FREQUENCY: 2.5
  },
  OBSTACLES: {
    MIN_SIZE: 35,
    MAX_SIZE: 55,
    MIN_SPEED: 2,
    MAX_SPEED: 4,
    SPAWN_COOLDOWN_MS: 800,
    BASE_SPAWN_PROBABILITY: 0.012,
    COLLISION_DAMAGE: 22,
    WAKE_TRAIL_LENGTH: 10
  },
  ITEMS: {
    WIDTH: 26,
    HEIGHT: 26,
    MIN_SPEED: 1.6,
    MAX_SPEED: 2.2,
    SPAWN_COOLDOWN_MS: 1200,
    BASE_SPAWN_PROBABILITY: 0.008,
    FUEL_RESTORE_AMOUNT: 30,
    HULL_REPAIR_AMOUNT: 35,
    SAILS_REPAIR_AMOUNT: 20
  },
  SEASONS: {
    NAMES: ['Winter', 'Summer', 'Monsoon', 'Storm'],
    CSS_CLASSES: ['winter', 'summer', 'monsoon', 'storm'],
    DURATION_MINUTES: [2, 2, 2, Infinity],
    STORM_DISTANCE_KM: 50,
    DIFFICULTY_SCALING: 0.7,
    DECAY_RATE_MULTIPLIER: 0.3,
    SPEED_MULTIPLIERS: [0.8, 1.0, 1.3, 1.3]
  },
  COMBO: {
    DURATION_SECONDS: 3,
    FUEL_BONUS_BASE: 50,
    REPAIR_BONUS_BASE: 75
  },
  PARTICLES: {
    MAX_ACTIVE_COUNT: iOSCheck ? 50 : 100,
    DEFAULT_LIFETIME: 0.6,
    LIFETIME_VARIANCE: 0.4,
    MIN_SIZE_PX: 1,
    MAX_SIZE_PX: 8,
    VELOCITY_RANGE: 150
  },
  WATER: {
    MAX_DROPLETS: iOSCheck ? 40 : 80,
    DROPLET_BASE_LIFETIME: 0.8,
    DROPLET_LIFETIME_VARIANCE: 0.7,
    GRAVITY_ACCELERATION: 150,
    SPLASH_VELOCITY_RANGE: 100
  },
  EFFECTS: {
    SCREEN_SHAKE_DURATION: 0.28,
    SCREEN_SHAKE_INTENSITY: 15,
    ITEM_SPARKLE_FREQUENCY: 8,
    WAKE_ALPHA: 0.6,
    WATER_REFLECTION_ALPHA: 0.2
  }
};

// Utils
const Utils = {
  clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  lerp(a, b, t) {
    return a + (b - a) * this.clamp(t, 0, 1);
  },
  randomRange(min, max) {
    return min + Math.random() * (max - min);
  },
  randomInt(min, max) {
    return Math.floor(this.randomRange(min, max + 1));
  },
  aabb(a, b) {
    return a && b && a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
  },
  isMobile() {
    return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  },
  distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  }
};

// Object Pool
const ObjectPool = {
  particles: [],
  waterDroplets: [],
  wakeTrailNodes: [],
  sparkles: [],

  getParticle() {
    return this.particles.pop() || { x: 0, y: 0, vx: 0, vy: 0, color: '#ffffff', life: 0, maxLife: 0, alpha: 1, size: 2, gravity: false };
  },
  releaseParticle(particle) {
    if (this.particles.length < 100) this.particles.push(particle);
  },
  getWaterDroplet() {
    return this.waterDroplets.pop() || { x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, alpha: 1, size: 2 };
  },
  releaseWaterDroplet(droplet) {
    if (this.waterDroplets.length < 80) this.waterDroplets.push(droplet);
  },
  getWakeNode() {
    return this.wakeTrailNodes.pop() || { x: 0, y: 0, age: 0, maxAge: 1 };
  },
  releaseWakeNode(node) {
    if (this.wakeTrailNodes.length < 200) this.wakeTrailNodes.push(node);
  },
  getSparkle() {
    return this.sparkles.pop() || { x: 0, y: 0, life: 0, maxLife: 0, alpha: 1, size: 2, phase: 0 };
  },
  releaseSparkle(sparkle) {
    if (this.sparkles.length < 50) this.sparkles.push(sparkle);
  }
};

// Particle System
const ParticleSystem = {
  particles: [],
  waterDroplets: [],
  sparkles: [],

  update(deltaTime) {
    this.updateParticles(deltaTime);
    this.updateWaterDroplets(deltaTime);
    this.updateSparkles(deltaTime);
  },

  updateParticles(deltaTime) {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const particle = this.particles[i];

      particle.x += particle.vx * deltaTime;
      particle.y += particle.vy * deltaTime;
      if (particle.gravity) {
        particle.vy += 200 * deltaTime;
      }

      particle.life += deltaTime;
      particle.alpha = 1 - (particle.life / particle.maxLife);

      if (particle.life >= particle.maxLife || particle.alpha <= 0) {
        ObjectPool.releaseParticle(particle);
        this.particles.splice(i, 1);
      }
    }
  },

  updateWaterDroplets(deltaTime) {
    for (let i = this.waterDroplets.length - 1; i >= 0; i--) {
      const droplet = this.waterDroplets[i];

      droplet.x += droplet.vx * deltaTime;
      droplet.y += droplet.vy * deltaTime;
      droplet.vy += CONFIG.WATER.GRAVITY_ACCELERATION * deltaTime;

      droplet.life += deltaTime;
      droplet.alpha = Math.max(0, 1 - (droplet.life / droplet.maxLife));

      if (droplet.life >= droplet.maxLife || droplet.y > GameState.height + 50) {
        ObjectPool.releaseWaterDroplet(droplet);
        this.waterDroplets.splice(i, 1);
      }
    }
  },

  updateSparkles(deltaTime) {
    for (let i = this.sparkles.length - 1; i >= 0; i--) {
      const sparkle = this.sparkles[i];

      sparkle.life += deltaTime;
      sparkle.phase += deltaTime * CONFIG.EFFECTS.ITEM_SPARKLE_FREQUENCY;
      sparkle.alpha = Math.max(0, 1 - (sparkle.life / sparkle.maxLife)) * (0.5 + 0.5 * Math.sin(sparkle.phase));

      if (sparkle.life >= sparkle.maxLife) {
        ObjectPool.releaseSparkle(sparkle);
        this.sparkles.splice(i, 1);
      }
    }
  },

  createParticles(x, y, color, count, options = {}) {
    const defaults = {
      velocity: CONFIG.PARTICLES.VELOCITY_RANGE,
      lifetime: CONFIG.PARTICLES.DEFAULT_LIFETIME,
      size: 3,
      gravity: false
    };
    const settings = { ...defaults, ...options };

    for (let i = 0; i < count && this.particles.length < CONFIG.PARTICLES.MAX_ACTIVE_COUNT; i++) {
      const particle = ObjectPool.getParticle();
      const angle = (Math.PI * 2 * i) / count + Utils.randomRange(-0.5, 0.5);
      const velocity = Utils.randomRange(settings.velocity * 0.5, settings.velocity);

      particle.x = x;
      particle.y = y;
      particle.vx = Math.cos(angle) * velocity;
      particle.vy = Math.sin(angle) * velocity;
      particle.color = color;
      particle.life = 0;
      particle.maxLife = settings.lifetime + Utils.randomRange(-CONFIG.PARTICLES.LIFETIME_VARIANCE, CONFIG.PARTICLES.LIFETIME_VARIANCE);
      particle.alpha = 1;
      particle.size = Utils.randomRange(settings.size * 0.7, settings.size * 1.3);
      particle.gravity = settings.gravity;

      this.particles.push(particle);
    }
  },

  createWaterDroplets(x, y, count) {
    for (let i = 0; i < count && this.waterDroplets.length < CONFIG.WATER.MAX_DROPLETS; i++) {
      const droplet = ObjectPool.getWaterDroplet();
      const angle = Utils.randomRange(-Math.PI, 0);
      const velocity = Utils.randomRange(50, CONFIG.WATER.SPLASH_VELOCITY_RANGE);

      droplet.x = x + Utils.randomRange(-10, 10);
      droplet.y = y + Utils.randomRange(-5, 5);
      droplet.vx = Math.cos(angle) * velocity;
      droplet.vy = Math.sin(angle) * velocity;
      droplet.life = 0;
      droplet.maxLife = CONFIG.WATER.DROPLET_BASE_LIFETIME + Utils.randomRange(-CONFIG.WATER.DROPLET_LIFETIME_VARIANCE, CONFIG.WATER.DROPLET_LIFETIME_VARIANCE);
      droplet.alpha = 1;
      droplet.size = Utils.randomRange(2, 5);

      this.waterDroplets.push(droplet);
    }
  },

  createSparklesAroundItem(item) {
    const sparkleCount = 3;
    for (let i = 0; i < sparkleCount && this.sparkles.length < 30; i++) {
      const sparkle = ObjectPool.getSparkle();
      const angle = (Math.PI * 2 * i) / sparkleCount;
      const distance = 15;

      sparkle.x = item.x + item.width/2 + Math.cos(angle) * distance;
      sparkle.y = item.y + item.height/2 + Math.sin(angle) * distance;
      sparkle.life = 0;
      sparkle.maxLife = 0.5 + Math.random() * 0.3;
      sparkle.alpha = 1;
      sparkle.size = Utils.randomRange(2, 4);
      sparkle.phase = Math.random() * Math.PI * 2;

      this.sparkles.push(sparkle);
    }
  },

  clear() {
    this.particles.forEach(p => ObjectPool.releaseParticle(p));
    this.waterDroplets.forEach(d => ObjectPool.releaseWaterDroplet(d));
    this.sparkles.forEach(s => ObjectPool.releaseSparkle(s));

    this.particles.length = 0;
    this.waterDroplets.length = 0;
    this.sparkles.length = 0;
  }
};

// Wake Trail System
const WakeTrailSystem = {
  playerWake: [],
  obstacleWakes: new Map(),

  update(deltaTime) {
    this.updatePlayerWake(deltaTime);
    this.updateObstacleWakes(deltaTime);
  },

  updatePlayerWake(deltaTime) {
    const playerCenterX = Player.x + Player.width / 2;
    const playerCenterY = Player.y + Player.height;

    if (this.playerWake.length === 0 ||
      Utils.distance(playerCenterX, playerCenterY, this.playerWake[0].x, this.playerWake[0].y) > 8) {
      const wakeNode = ObjectPool.getWakeNode();
      wakeNode.x = playerCenterX;
      wakeNode.y = playerCenterY;
      wakeNode.age = 0;
      wakeNode.maxAge = 1.5;
      this.playerWake.unshift(wakeNode);
    }

    for (let i = this.playerWake.length - 1; i >= 0; i--) {
      const node = this.playerWake[i];
      node.age += deltaTime;

      if (node.age >= node.maxAge || this.playerWake.length > CONFIG.PLAYER.WAKE_TRAIL_LENGTH) {
        ObjectPool.releaseWakeNode(node);
        this.playerWake.splice(i, 1);
      }
    }
  },

  updateObstacleWakes(deltaTime) {
    const activeObstacles = new Set(GameObjects.obstacles);
    for (const obstacleId of this.obstacleWakes.keys()) {
      if (!activeObstacles.has(obstacleId)) {
        const wake = this.obstacleWakes.get(obstacleId);
        wake.forEach(node => ObjectPool.releaseWakeNode(node));
        this.obstacleWakes.delete(obstacleId);
      }
    }

    GameObjects.obstacles.forEach(obstacle => {
      if (!this.obstacleWakes.has(obstacle)) {
        this.obstacleWakes.set(obstacle, []);
      }

      const wake = this.obstacleWakes.get(obstacle);
      const centerX = obstacle.x + obstacle.width / 2;
      const centerY = obstacle.y + obstacle.height;

      if (wake.length === 0 || Utils.distance(centerX, centerY, wake[0].x, wake[0].y) > 10) {
        const wakeNode = ObjectPool.getWakeNode();
        wakeNode.x = centerX;
        wakeNode.y = centerY;
        wakeNode.age = 0;
        wakeNode.maxAge = 1.0;
        wake.unshift(wakeNode);
      }

      for (let i = wake.length - 1; i >= 0; i--) {
        const node = wake[i];
        node.age += deltaTime;

        if (node.age >= node.maxAge || wake.length > CONFIG.OBSTACLES.WAKE_TRAIL_LENGTH) {
          ObjectPool.releaseWakeNode(node);
          wake.splice(i, 1);
        }
      }
    });
  },

  clear() {
    this.playerWake.forEach(node => ObjectPool.releaseWakeNode(node));
    this.playerWake.length = 0;

    this.obstacleWakes.forEach(wake => {
      wake.forEach(node => ObjectPool.releaseWakeNode(node));
    });
    this.obstacleWakes.clear();
  }
};

// Game State
const GameState = {
  canvas: null,
  ctx: null,
  width: 0,
  height: 0,
  running: false,
  paused: false,
  lastTime: 0,
  distance: 0,
  crashes: 0,
  season: 0,
  lastSeason: -1,
  seasonStartTime: 0,
  shakeTime: 0,
  combo: 0,
  comboTimer: 0,
  isMobile: Utils.isMobile(),
  lastObstacleSpawn: 0,
  lastItemSpawn: 0,
  oceanTime: 0,
  devicePixelRatio: CONFIG.CANVAS.MAX_DEVICE_PIXEL_RATIO,
  initialPlayerY: 0,
  controlsVisible: false,
  cachedElements: {},
  lastPlayerX: 0,
  lastPlayerY: 0,

  cacheElement(id) {
    if (!this.cachedElements[id]) {
      this.cachedElements[id] = document.getElementById(id);
    }
    return this.cachedElements[id];
  },

  reset() {
    Object.assign(this, {
      distance: 0,
      crashes: 0,
      season: 0,
      lastSeason: -1,
      seasonStartTime: performance.now(),
      shakeTime: 0,
      combo: 0,
      comboTimer: 0,
      paused: false,
      lastObstacleSpawn: 0,
      lastItemSpawn: 0,
      oceanTime: 0,
      controlsVisible: false,
      lastPlayerX: 0,
      lastPlayerY: 0
    });
  }
};

// Player
const Player = {
  x: 0,
  y: 0,
  width: CONFIG.PLAYER.WIDTH,
  height: CONFIG.PLAYER.HEIGHT,
  speed: CONFIG.PLAYER.SPEED,
  hull: 100,
  fuel: 100,
  sails: 100,
  hullDecay: CONFIG.PLAYER.HULL_DECAY_RATE,
  fuelDecay: CONFIG.PLAYER.FUEL_CONSUMPTION_RATE,
  sailsDecay: CONFIG.PLAYER.SAILS_WEAR_RATE,
  bobOffset: 0,
  damageSpots: [],
  isMoving: false,
  lastMoveTime: 0,

  reset() {
    Object.assign(this, {
      hull: 100,
      fuel: 100,
      sails: 100,
      bobOffset: 0,
      isMoving: false,
      lastMoveTime: 0,
      damageSpots: []
    });
  },

  update(deltaTime, keys, touchState) {
    const oldX = this.x;
    const oldY = this.y;
    this.updateMovement(deltaTime, keys, touchState);
    this.updateBoundaries();
    this.updateResources(deltaTime);
    this.updateEffects(deltaTime);
    this.updateMovementEffects(oldX, oldY, deltaTime);
  },

  updateMovement(deltaTime, keys, touchState) {
    const sailEfficiency = Utils.clamp(this.sails / 100, CONFIG.PLAYER.MIN_EFFICIENCY, 1);
    const seasonSpeedMultiplier = CONFIG.SEASONS.SPEED_MULTIPLIERS[GameState.season] || 1;
    const sensitivityMultiplier = CONFIG.PLAYER.SENSITIVITY;
    const moveSpeed = this.speed * sailEfficiency * seasonSpeedMultiplier * sensitivityMultiplier;

    this.isMoving = false;

    if (keys['ArrowLeft'] || keys['KeyA'] || touchState.left) {
      this.x -= moveSpeed;
      this.isMoving = true;
    }
    if (keys['ArrowRight'] || keys['KeyD'] || touchState.right) {
      this.x += moveSpeed;
      this.isMoving = true;
    }
    if (keys['ArrowUp'] || keys['KeyW'] || touchState.up) {
      this.y -= moveSpeed;
      this.isMoving = true;
    }
    if (keys['ArrowDown'] || keys['KeyS'] || touchState.down) {
      this.y += moveSpeed;
      this.isMoving = true;
    }

    if (this.isMoving) {
      this.lastMoveTime = performance.now();
    }
  },

  updateBoundaries() {
    this.x = Utils.clamp(this.x, CONFIG.PLAYER.SIDE_MARGIN, GameState.width - this.width - CONFIG.PLAYER.SIDE_MARGIN);
    this.y = Utils.clamp(this.y, CONFIG.PLAYER.TOP_MARGIN, GameState.height - this.height - CONFIG.PLAYER.BOTTOM_MARGIN);
  },

  updateResources(deltaTime) {
    const decayMultiplier = 1 + GameState.season * CONFIG.SEASONS.DECAY_RATE_MULTIPLIER;
    this.hull = Utils.clamp(this.hull - this.hullDecay * deltaTime * decayMultiplier, 0, 100);
    this.fuel = Utils.clamp(this.fuel - this.fuelDecay * deltaTime * decayMultiplier, 0, 100);
    this.sails = Utils.clamp(this.sails - this.sailsDecay * deltaTime * decayMultiplier, 0, 100);

    this.updateDamageSpots();
  },

  updateDamageSpots() {
    const targetSpots = Math.floor((100 - this.hull) / 15);
    while (this.damageSpots.length < targetSpots) {
      this.damageSpots.push({
        x: Utils.randomRange(0.2, 0.8),
        y: Utils.randomRange(0.3, 0.7),
        size: Utils.randomRange(0.1, 0.2),
        intensity: Utils.randomRange(0.6, 1.0)
      });
    }
    while (this.damageSpots.length > targetSpots) {
      this.damageSpots.pop();
    }
  },

  updateEffects(deltaTime) {
    this.updateBobbing();
  },

  updateBobbing() {
    this.bobOffset = Math.sin(GameState.oceanTime * CONFIG.PLAYER.BOB_FREQUENCY) * CONFIG.PLAYER.BOB_AMPLITUDE;
  },

  updateMovementEffects(oldX, oldY, deltaTime) {
    if (Math.abs(this.x - oldX) > 1) {
      const centerX = this.x + this.width / 2;
      const waterY = this.y + this.height;
      ParticleSystem.createWaterDroplets(centerX, waterY, 2);
    }

    GameState.lastPlayerX = this.x;
    GameState.lastPlayerY = this.y;
  },

  setInitialPosition() {
    this.x = (GameState.width - this.width) / 2;
    this.y = GameState.height * 0.7;
    GameState.initialPlayerY = this.y;
  },

  repositionOnResize() {
    this.x = Utils.clamp(this.x, CONFIG.PLAYER.SIDE_MARGIN, GameState.width - this.width - CONFIG.PLAYER.SIDE_MARGIN);
    this.y = Utils.clamp(this.y, CONFIG.PLAYER.TOP_MARGIN, GameState.height - this.height - CONFIG.PLAYER.BOTTOM_MARGIN);
  }
};

// Game Objects
const GameObjects = {
  obstacles: [],
  items: [],

  update(deltaTime) {
    this.updateObstacles(deltaTime);
    this.updateItems(deltaTime);
    this.spawnObjects();
  },

  updateObstacles(deltaTime) {
    for (let i = this.obstacles.length - 1; i >= 0; i--) {
      const obstacle = this.obstacles[i];
      obstacle.y += obstacle.speed;
      if (obstacle.y > GameState.height + 100) {
        this.obstacles.splice(i, 1);
      }
    }
  },

  updateItems(deltaTime) {
    for (let i = this.items.length - 1; i >= 0; i--) {
      const item = this.items[i];
      item.y += item.speed;
      item.sparkleTime += deltaTime;

      if (Math.random() < 0.1) {
        ParticleSystem.createSparklesAroundItem(item);
      }

      if (item.y > GameState.height + 50) {
        this.items.splice(i, 1);
      }
    }
  },

  spawnObjects() {
    const seasonMultiplier = 1 + GameState.season * CONFIG.SEASONS.DIFFICULTY_SCALING;
    const currentTime = performance.now();

    const timeSinceObstacle = currentTime - GameState.lastObstacleSpawn;
    if (timeSinceObstacle > (CONFIG.OBSTACLES.SPAWN_COOLDOWN_MS / seasonMultiplier)) {
      if (Math.random() < CONFIG.OBSTACLES.BASE_SPAWN_PROBABILITY * seasonMultiplier) {
        this.spawnObstacle();
        GameState.lastObstacleSpawn = currentTime;
      }
    }

    const timeSinceItem = currentTime - GameState.lastItemSpawn;
    if (timeSinceItem > CONFIG.ITEMS.SPAWN_COOLDOWN_MS) {
      if (Math.random() < CONFIG.ITEMS.BASE_SPAWN_PROBABILITY) {
        this.spawnItem();
        GameState.lastItemSpawn = currentTime;
      }
    }
  },

  spawnObstacle() {
    const size = Utils.clamp(CONFIG.OBSTACLES.MIN_SIZE + Math.random() * 20, CONFIG.OBSTACLES.MIN_SIZE, CONFIG.OBSTACLES.MAX_SIZE);
    const obstacle = {
      x: Utils.clamp(Math.random() * (GameState.width - size), 0, GameState.width - size),
      y: -60,
      width: size,
      height: size * 1.2,
      speed: Utils.clamp(CONFIG.OBSTACLES.MIN_SPEED + GameState.season * 1.1 + Math.random() * 1.8, CONFIG.OBSTACLES.MIN_SPEED, CONFIG.OBSTACLES.MAX_SPEED + GameState.season),
      type: 'enemyShip'
    };
    this.obstacles.push(obstacle);
  },

  spawnItem() {
    const item = {
      x: Utils.clamp(Math.random() * (GameState.width - CONFIG.ITEMS.WIDTH), 0, GameState.width - CONFIG.ITEMS.WIDTH),
      y: -CONFIG.ITEMS.HEIGHT,
      width: CONFIG.ITEMS.WIDTH,
      height: CONFIG.ITEMS.HEIGHT,
      speed: Utils.clamp(CONFIG.ITEMS.MIN_SPEED + GameState.season * 0.6, CONFIG.ITEMS.MIN_SPEED, CONFIG.ITEMS.MAX_SPEED),
      type: Math.random() < 0.5 ? 'fuel' : 'repair',
      bobOffset: Math.random() * Math.PI * 2,
      sparkleTime: 0
    };
    this.items.push(item);
  },

  clear() {
    this.obstacles.length = 0;
    this.items.length = 0;
  }
};

// Collision System
const CollisionSystem = {
  checkCollisions() {
    this.checkObstacleCollisions();
    this.checkItemCollisions();
  },

  checkObstacleCollisions() {
    for (let i = GameObjects.obstacles.length - 1; i >= 0; i--) {
      const obstacle = GameObjects.obstacles[i];
      if (obstacle && Utils.aabb(Player, obstacle)) {
        GameObjects.obstacles.splice(i, 1);
        this.handleObstacleHit(obstacle);
      }
    }
  },

  checkItemCollisions() {
    for (let i = GameObjects.items.length - 1; i >= 0; i--) {
      const item = GameObjects.items[i];
      if (item && Utils.aabb(Player, item)) {
        GameObjects.items.splice(i, 1);
        this.handleItemCollection(item);
      }
    }
  },

  handleObstacleHit(obstacle) {
    GameState.crashes++;
    
    GameState.combo = 0;
    const indicator = GameState.cacheElement('comboIndicator');
    if (indicator) indicator.style.display = 'none';

    Player.hull = Math.max(0, Player.hull - CONFIG.OBSTACLES.COLLISION_DAMAGE);
    GameState.shakeTime = CONFIG.EFFECTS.SCREEN_SHAKE_DURATION;

    const centerX = obstacle.x + obstacle.width / 2;
    const centerY = obstacle.y + obstacle.height / 2;
    ParticleSystem.createParticles(centerX, centerY, '#ff4444', 12, {
      velocity: 200,
      lifetime: 0.8,
      gravity: true
    });
    ParticleSystem.createWaterDroplets(centerX, centerY, 8);

    const gameContainer = document.getElementById('gameContainer');
    if (gameContainer) {
      gameContainer.classList.add('shake');
      setTimeout(() => gameContainer.classList.remove('shake'), CONFIG.EFFECTS.SCREEN_SHAKE_DURATION * 1000);
    }
  },

  handleItemCollection(item) {
    GameState.combo = Math.max(1, GameState.combo + 1);
    GameState.comboTimer = CONFIG.COMBO.DURATION_SECONDS;

    const centerX = item.x + item.width / 2;
    const centerY = item.y + item.height / 2;
    const color = item.type === 'fuel' ? '#ffaa00' : '#44ff44';
    ParticleSystem.createParticles(centerX, centerY, color, 8, {
      velocity: 100,
      lifetime: 0.6
    });
    ParticleSystem.createWaterDroplets(centerX, centerY, 4);

    if (GameState.combo > 1) {
      const countElement = GameState.cacheElement('comboCount');
      const bonusElement = GameState.cacheElement('comboBonus');
      const indicator = GameState.cacheElement('comboIndicator');
      const comboBonus = CONFIG.COMBO.FUEL_BONUS_BASE * (GameState.combo - 1);

      if (countElement) countElement.textContent = GameState.combo;
      if (bonusElement) bonusElement.textContent = comboBonus;
      if (indicator) indicator.style.display = 'block';
    }

    if (item.type === 'fuel') {
      Player.fuel = Math.min(100, Player.fuel + CONFIG.ITEMS.FUEL_RESTORE_AMOUNT);
    } else {
      Player.hull = Math.min(100, Player.hull + CONFIG.ITEMS.HULL_REPAIR_AMOUNT);
      Player.sails = Math.min(100, Player.sails + CONFIG.ITEMS.SAILS_REPAIR_AMOUNT);
    }
  }
};

// Season System
const SeasonSystem = {
  update() {
    const currentTime = performance.now();
    const elapsedMinutes = (currentTime - GameState.seasonStartTime) / (1000 * 60);
    const distanceKm = GameState.distance / 1000;

    let newSeason;
    if (distanceKm >= CONFIG.SEASONS.STORM_DISTANCE_KM) {
      newSeason = 3;
    } else if (elapsedMinutes < CONFIG.SEASONS.DURATION_MINUTES[0]) {
      newSeason = 0;
    } else if (elapsedMinutes < CONFIG.SEASONS.DURATION_MINUTES[0] + CONFIG.SEASONS.DURATION_MINUTES[1]) {
      newSeason = 1;
    } else {
      newSeason = 2;
    }

    if (newSeason !== GameState.season) {
      GameState.lastSeason = GameState.season;
      GameState.season = newSeason;
      this.triggerSeasonTransition();
    }
  },

  triggerSeasonTransition() {
    const gameContainer = document.getElementById('gameContainer');
    if (gameContainer) {
      const flash = document.createElement('div');
      flash.className = 'season-transition';
      gameContainer.appendChild(flash);
      setTimeout(() => gameContainer.removeChild(flash), 1000);
    }
  }
};

// Renderer
const Renderer = {
  render() {
    const ctx = GameState.ctx;
    if (!ctx) return;

    ctx.save();
    ctx.imageSmoothingEnabled = CONFIG.CANVAS.ENABLE_ANTIALIASING;
    ctx.imageSmoothingQuality = 'high';

    if (GameState.shakeTime > 0) {
      const intensity = GameState.shakeTime * CONFIG.EFFECTS.SCREEN_SHAKE_INTENSITY;
      const shakeX = (Math.random() - 0.5) * intensity;
      const shakeY = (Math.random() - 0.5) * intensity;
      ctx.translate(shakeX, shakeY);
    }

    this.renderOcean(ctx);
    this.renderOceanFloor(ctx);
    this.renderWakeTrails(ctx);
    this.renderPlayer(ctx);
    this.renderObstacles(ctx);
    this.renderItems(ctx);
    this.renderParticles(ctx);

    ctx.restore();
  },

  renderOcean(ctx) {
    const gradient = ctx.createLinearGradient(0, 0, 0, GameState.height);
    const colorSets = [
      { surface: '#B0E0E6', shallow: '#4682B4', deep: '#191970' },
      { surface: '#87CEEB', shallow: '#4682B4', deep: '#191970' },
      { surface: '#708090', shallow: '#2F4F4F', deep: '#1C3A3A' },
      { surface: '#2F2F2F', shallow: '#1C1C1C', deep: '#000000' }
    ];
    const colors = colorSets[Utils.clamp(GameState.season, 0, colorSets.length - 1)];

    gradient.addColorStop(0, colors.surface);
    gradient.addColorStop(0.3, colors.shallow);
    gradient.addColorStop(0.7, colors.deep);
    gradient.addColorStop(1, colors.deep);

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, GameState.width, GameState.height);
  },

  renderOceanFloor(ctx) {
    ctx.save();
    ctx.globalAlpha = 0.3;

    const waveOffset = GameState.oceanTime * 30;
    for (let x = -50; x < GameState.width + 50; x += 40) {
      const waveHeight = Math.sin((x + waveOffset) * 0.02) * 20;
      const seaweedHeight = 60 + waveHeight;

      ctx.strokeStyle = '#2d5a3d';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x, GameState.height);

      for (let i = 0; i <= 10; i++) {
        const t = i / 10;
        const y = GameState.height - seaweedHeight * t;
        const wobble = Math.sin(GameState.oceanTime * 3 + x * 0.1 + t * 5) * (5 * t);
        ctx.lineTo(x + wobble, y);
      }

      ctx.stroke();
    }

    ctx.restore();
  },

  renderWakeTrails(ctx) {
    ctx.save();
    ctx.globalAlpha = CONFIG.EFFECTS.WAKE_ALPHA;

    this.renderWakeTrail(ctx, WakeTrailSystem.playerWake, 'rgba(255, 255, 255, 0.8)');

    WakeTrailSystem.obstacleWakes.forEach(wake => {
      this.renderWakeTrail(ctx, wake, 'rgba(200, 200, 200, 0.6)');
    });

    ctx.restore();
  },

  renderWakeTrail(ctx, trail, color) {
    if (trail.length < 2) return;

    ctx.strokeStyle = color;
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    for (let i = 0; i < trail.length - 1; i++) {
      const node = trail[i];
      const nextNode = trail[i + 1];
      const alpha = 1 - (node.age / node.maxAge);

      ctx.save();
      ctx.globalAlpha = alpha * 0.8;
      ctx.lineWidth = 8 * alpha;

      ctx.beginPath();
      ctx.moveTo(Math.round(node.x), Math.round(node.y));
      ctx.lineTo(Math.round(nextNode.x), Math.round(nextNode.y));
      ctx.stroke();

      ctx.restore();
    }
  },

  renderPlayer(ctx) {
    const playerY = Player.y + (Player.bobOffset || 0);
    this.drawPlayerShip(ctx, Player.x, playerY, Player.width, Player.height);
  },

  drawPlayerShip(ctx, x, y, width, height) {
    ctx.save();
    ctx.translate(Math.round(x + width / 2), Math.round(y + height / 2));

    const hullGradient = ctx.createLinearGradient(-width/2, -height/2, width/2, height/2);
    const hullColors = [
      { color1: '#f8f8ff', color2: '#e6e6fa', stroke: '#d0d0d0' },
      { color1: '#f0f0e0', color2: '#e8e0d0', stroke: '#c0b0a0' },
      { color1: '#e8e0d0', color2: '#d0c0b0', stroke: '#a08070' },
      { color1: '#d0c0b0', color2: '#b08060', stroke: '#805040' }
    ];
    const colorIndex = [75, 50, 25].findIndex(t => Player.hull > t);
    const hullColor = hullColors[colorIndex === -1 ? hullColors.length - 1 : colorIndex];

    hullGradient.addColorStop(0, hullColor.color1);
    hullGradient.addColorStop(1, hullColor.color2);

    ctx.fillStyle = hullGradient;
    ctx.strokeStyle = hullColor.stroke;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, -height * 0.55);
    ctx.quadraticCurveTo(width * 0.45, -height * 0.25, width * 0.38, height * 0.40);
    ctx.lineTo(-width * 0.38, height * 0.40);
    ctx.quadraticCurveTo(-width * 0.45, -height * 0.25, 0, -height * 0.55);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    Player.damageSpots.forEach(spot => {
      ctx.fillStyle = `rgba(101, 67, 33, ${spot.intensity})`;
      const spotX = Math.round((spot.x - 0.5) * width * 0.7);
      const spotY = Math.round((spot.y - 0.5) * height * 0.8);
      const spotSize = spot.size * Math.min(width, height) * 1.5;

      ctx.beginPath();
      ctx.arc(spotX, spotY, spotSize, 0, Math.PI * 2);
      ctx.fill();
    });

    const mastGradient = ctx.createLinearGradient(-2, -height * 0.48, 2, height * 0.3);
    mastGradient.addColorStop(0, '#8B4513');
    mastGradient.addColorStop(1, '#654321');
    ctx.fillStyle = mastGradient;
    ctx.fillRect(-2, -height * 0.48, 4, height * 0.78);

    const sailAlpha = Utils.clamp(0.85 * Math.max(0.25, Player.sails / 100), 0.2, 1);

    const sailGradient = ctx.createLinearGradient(0, -height * 0.45, width * 0.30, -height * 0.05);
    sailGradient.addColorStop(0, `rgba(255, 255, 255, ${sailAlpha})`);
    sailGradient.addColorStop(1, `rgba(240, 240, 240, ${sailAlpha * 0.8})`);

    ctx.fillStyle = sailGradient;
    ctx.strokeStyle = `rgba(200, 200, 200, ${sailAlpha})`;
    ctx.lineWidth = 1;

    const windEffect = Math.sin(GameState.oceanTime * 3) * 2;
    ctx.beginPath();
    ctx.moveTo(0, -height * 0.45);
    ctx.quadraticCurveTo(width * 0.30 + windEffect, -height * 0.25, width * 0.30, -height * 0.05);
    ctx.lineTo(0, -height * 0.05);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = `rgba(255, 255, 255, ${sailAlpha * 0.9})`;
    ctx.beginPath();
    ctx.moveTo(0, -height * 0.45);
    ctx.quadraticCurveTo(width * 0.20 + windEffect * 0.7, -height * 0.35, width * 0.20, -height * 0.25);
    ctx.lineTo(0, -height * 0.25);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = hullColor.stroke;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-width * 0.25, height * 0.15);
    ctx.lineTo(width * 0.25, height * 0.15);
    ctx.stroke();

    ctx.restore();
  },

  renderObstacles(ctx) {
    GameObjects.obstacles.forEach(obstacle => {
      const bobbing = Math.sin(GameState.oceanTime * 2 + obstacle.x * 0.01) * 2;
      const renderY = obstacle.y + bobbing;

      ctx.save();
      ctx.translate(Math.round(obstacle.x + obstacle.width / 2), Math.round(renderY + obstacle.height / 2));

      const enemyGradient = ctx.createLinearGradient(-obstacle.width/2, -obstacle.height/2, obstacle.width/2, obstacle.height/2);
      enemyGradient.addColorStop(0, '#2c2c2c');
      enemyGradient.addColorStop(0.5, '#1a1a1a');
      enemyGradient.addColorStop(1, '#0a0a0a');

      ctx.fillStyle = enemyGradient;
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, obstacle.height * 0.50);
      ctx.quadraticCurveTo(obstacle.width * 0.48, obstacle.height * 0.18, obstacle.width * 0.36, -obstacle.height * 0.42);
      ctx.lineTo(-obstacle.width * 0.36, -obstacle.height * 0.42);
      ctx.quadraticCurveTo(-obstacle.width * 0.48, obstacle.height * 0.18, 0, obstacle.height * 0.50);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#654321';
      ctx.fillRect(-1.5, -obstacle.height * 0.35, 3, obstacle.height * 0.6);

      ctx.fillStyle = 'rgba(60, 60, 60, 0.8)';
      ctx.strokeStyle = 'rgba(40, 40, 40, 0.9)';
      ctx.lineWidth = 1;

      const enemyWindEffect = Math.sin(GameState.oceanTime * 2.5 + obstacle.x * 0.02) * 1.5;
      ctx.beginPath();
      ctx.moveTo(0, -obstacle.height * 0.32);
      ctx.quadraticCurveTo(obstacle.width * 0.22 + enemyWindEffect, -obstacle.height * 0.15, obstacle.width * 0.22, obstacle.height * 0.05);
      ctx.lineTo(0, obstacle.height * 0.05);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#333';
      for (let i = 0; i < 3; i++) {
        const cannonY = -obstacle.height * 0.1 + i * (obstacle.height * 0.1);
        ctx.fillRect(obstacle.width * 0.35, cannonY, obstacle.width * 0.08, 3);
      }

      ctx.restore();
    });
  },

  renderItems(ctx) {
    GameObjects.items.forEach(item => {
      const itemBob = Math.sin(item.sparkleTime * 3 + item.bobOffset) * 4;
      const waterBob = Math.sin(GameState.oceanTime * 2.5 + item.x * 0.02) * 1.5;
      const totalBobOffset = itemBob + waterBob;

      ctx.save();
      ctx.translate(Math.round(item.x + item.width / 2), Math.round(item.y + item.height / 2 + totalBobOffset));

      const glowIntensity = 0.5 + 0.3 * Math.sin(GameState.oceanTime * 4);
      ctx.shadowColor = item.type === 'fuel' ? '#ffaa00' : '#44ff44';
      ctx.shadowBlur = 12 * glowIntensity;

      if (item.type === 'fuel') {
        const fuelGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, item.width/2);
        fuelGradient.addColorStop(0, '#ff9900');
        fuelGradient.addColorStop(0.7, '#ff6600');
        fuelGradient.addColorStop(1, '#cc4400');
        ctx.fillStyle = fuelGradient;
        ctx.fillRect(-item.width / 2, -item.height / 2, item.width, item.height);

        ctx.fillStyle = '#994400';
        ctx.fillRect(-item.width / 2, -item.height / 2 + 3, item.width, 2);
        ctx.fillRect(-item.width / 2, item.height / 2 - 5, item.width, 2);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('F', 0, 4);
      } else {
        const repairGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, item.width/2);
        repairGradient.addColorStop(0, '#44ff44');
        repairGradient.addColorStop(0.7, '#228b22');
        repairGradient.addColorStop(1, '#006400');
        ctx.fillStyle = repairGradient;
        ctx.fillRect(-item.width / 2, -item.height / 2, item.width, item.height);

        ctx.strokeStyle = '#004400';
        ctx.lineWidth = 2;
        ctx.strokeRect(-item.width / 2, -item.height / 2, item.width, item.height);

        ctx.fillStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-8, 0);
        ctx.lineTo(8, 0);
        ctx.moveTo(0, -8);
        ctx.lineTo(0, 8);
        ctx.stroke();
      }

      ctx.restore();
    });
  },

  renderParticles(ctx) {
    ParticleSystem.particles.forEach(particle => {
      ctx.save();
      ctx.globalAlpha = particle.alpha;
      ctx.fillStyle = particle.color;
      ctx.beginPath();
      ctx.arc(Math.round(particle.x), Math.round(particle.y), particle.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });

    ParticleSystem.waterDroplets.forEach(droplet => {
      ctx.save();
      ctx.globalAlpha = droplet.alpha * 0.8;
      ctx.fillStyle = '#87ceeb';
      ctx.beginPath();
      ctx.arc(Math.round(droplet.x), Math.round(droplet.y), droplet.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });

    ParticleSystem.sparkles.forEach(sparkle => {
      ctx.save();
      ctx.globalAlpha = sparkle.alpha;
      ctx.fillStyle = '#ffff88';
      ctx.translate(Math.round(sparkle.x), Math.round(sparkle.y));
      ctx.rotate(sparkle.phase);

      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const angle = (i * Math.PI) / 4;
        const radius = (i % 2 === 0) ? sparkle.size : sparkle.size * 0.4;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    });
  }
};

// HUD Manager
const HudManager = {
  lastUpdate: 0,
  updateInterval: 100,
  lastValues: { distance: -1, crashes: -1, hull: -1, fuel: -1, season: -1 },

  update() {
    const now = performance.now();
    if (now - this.lastUpdate < this.updateInterval) return;

    this.updateGameStats();
    this.updateResourceBars();
    this.updateSeasonIndicator();
    this.updateCriticalWarnings();
    this.lastUpdate = now;
  },

  updateGameStats() {
    const distance = Math.max(0, Math.floor(GameState.distance / 1000));
    const crashes = Math.max(0, GameState.crashes);

    if (distance !== this.lastValues.distance) {
      const element = GameState.cacheElement('distance');
      if (element) element.textContent = distance + 'km';
      this.lastValues.distance = distance;
    }

    if (crashes !== this.lastValues.crashes) {
      const element = GameState.cacheElement('crashes');
      if (element) element.textContent = crashes;
      this.lastValues.crashes = crashes;
    }
  },

  updateResourceBars() {
    const hull = Utils.clamp(Math.round(Player.hull), 0, 100);
    const fuel = Utils.clamp(Math.round(Player.fuel), 0, 100);

    if (hull !== this.lastValues.hull) {
      const percentElement = GameState.cacheElement('hullPercent');
      const barElement = GameState.cacheElement('hullBar');
      if (percentElement) percentElement.textContent = hull + '%';
      if (barElement) {
        barElement.style.width = hull + '%';
        if (hull < 25) {
          barElement.style.background = 'linear-gradient(90deg,#ff0000,#ff4444)';
        } else if (hull < 50) {
          barElement.style.background = 'linear-gradient(90deg,#ff8800,#ffaa00)';
        } else {
          barElement.style.background = 'linear-gradient(90deg,#ff4444,#44ff44)';
        }
      }
      this.lastValues.hull = hull;
    }

    if (fuel !== this.lastValues.fuel) {
      const percentElement = GameState.cacheElement('fuelPercent');
      const barElement = GameState.cacheElement('fuelBar');
      if (percentElement) percentElement.textContent = fuel + '%';
      if (barElement) {
        barElement.style.width = fuel + '%';
        if (fuel < 25) {
          barElement.style.background = 'linear-gradient(90deg,#ff0000,#ff8800)';
        } else if (fuel < 50) {
          barElement.style.background = 'linear-gradient(90deg,#ff8800,#ffdd00)';
        } else {
          barElement.style.background = 'linear-gradient(90deg,#ff8800,#ffdd00)';
        }
      }
      this.lastValues.fuel = fuel;
    }
  },

  updateSeasonIndicator() {
    if (GameState.season === this.lastValues.season) return;

    const seasonElement = GameState.cacheElement('season');
    if (seasonElement) {
      const seasonIndex = Utils.clamp(GameState.season, 0, CONFIG.SEASONS.NAMES.length - 1);
      const distanceKm = GameState.distance / 1000;

      if (distanceKm >= CONFIG.SEASONS.STORM_DISTANCE_KM) {
        seasonElement.textContent = 'Storm';
        seasonElement.className = 'season-indicator storm';
      } else {
        seasonElement.textContent = CONFIG.SEASONS.NAMES[seasonIndex];
        seasonElement.className = 'season-indicator ' + CONFIG.SEASONS.CSS_CLASSES[seasonIndex];
      }
    }
    this.lastValues.season = GameState.season;
  },

  updateCriticalWarnings() {
    const hullBar = GameState.cacheElement('hullBar');
    const fuelBar = GameState.cacheElement('fuelBar');

    if (hullBar && Player.hull < 20) {
      hullBar.classList.add('critical-warning');
    } else if (hullBar) {
      hullBar.classList.remove('critical-warning');
    }

    if (fuelBar && Player.fuel < 20) {
      fuelBar.classList.add('critical-warning');
    } else if (fuelBar) {
      fuelBar.classList.remove('critical-warning');
    }
  }
};

// Sensitivity Manager
const SensitivityManager = {
  isInitialized: false,
  isDragging: false,

  init() {
    if (this.isInitialized) return;

    const sliderContainer = document.getElementById('sliderContainer');
    const sliderKnob = document.getElementById('sliderKnob');
    const sensitivityValue = document.getElementById('sensitivityValue');

    if (!sliderContainer || !sliderKnob || !sensitivityValue) return;

    sliderContainer.style.position = 'relative';
    sliderKnob.style.position = 'absolute';

    this.updateSliderPosition();

    sliderContainer.addEventListener('mousedown', this.onSliderStart.bind(this));
    document.addEventListener('mousemove', this.onSliderMove.bind(this));
    document.addEventListener('mouseup', this.onSliderEnd.bind(this));

    sliderContainer.addEventListener('touchstart', this.onSliderStart.bind(this), { passive: false });
    document.addEventListener('touchmove', this.onSliderMove.bind(this), { passive: false });
    document.addEventListener('touchend', this.onSliderEnd.bind(this));

    this.isInitialized = true;
  },

  onSliderStart(e) {
    e.preventDefault();
    this.isDragging = true;
    this.updateFromEvent(e);
  },

  onSliderMove(e) {
    if (!this.isDragging) return;
    e.preventDefault();
    this.updateFromEvent(e);
  },

  onSliderEnd(e) {
    this.isDragging = false;
  },

  updateFromEvent(e) {
    const sliderContainer = document.getElementById('sliderContainer');
    if (!sliderContainer) return;

    const rect = sliderContainer.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const x = Math.max(0, Math.min(rect.width, clientX - rect.left));
    const percentage = x / rect.width;

    CONFIG.PLAYER.SENSITIVITY = 0.5 + (percentage * 1.5);
    this.updateSliderPosition();
  },

  updateSliderPosition() {
    const sliderKnob = document.getElementById('sliderKnob');
    const sensitivityValue = document.getElementById('sensitivityValue');
    if (!sliderKnob || !sensitivityValue) return;

    const percentage = (CONFIG.PLAYER.SENSITIVITY - 0.5) / 1.5;
    sliderKnob.style.left = (percentage * 100) + '%';

    const sensitivityText = CONFIG.PLAYER.SENSITIVITY.toFixed(1) + 'x';
    const label = CONFIG.PLAYER.SENSITIVITY < 0.8 ? 'Slow' :
                  CONFIG.PLAYER.SENSITIVITY > 1.2 ? 'Fast' : 'Normal';
    sensitivityValue.textContent = `${label} (${sensitivityText})`;
  }
};

// Input Manager
const InputManager = {
  keys: {},
  touchState: { left: false, right: false, up: false, down: false },
  joystick: {
    active: false,
    centerX: 0,
    centerY: 0,
    knobX: 0,
    knobY: 0,
    radius: 60,
    knobRadius: 25,
    deltaX: 0,
    deltaY: 0
  },

  init() {
    this.setupKeyboardEvents();
    if (GameState.isMobile) {
      this.setupVirtualJoystick();
    }
  },

  setupKeyboardEvents() {
    document.addEventListener('keydown', this.onKeyDown.bind(this));
    document.addEventListener('keyup', this.onKeyUp.bind(this));
  },

  onKeyDown(e) {
    this.keys[e.code] = true;
    if (e.code === 'Space') {
      e.preventDefault();
      GameManager.togglePause();
    }
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'KeyA', 'KeyD', 'KeyW', 'KeyS'].includes(e.code)) {
      e.preventDefault();
      this.showControls();
    }
  },

  onKeyUp(e) {
    this.keys[e.code] = false;
  },

  setupVirtualJoystick() {
    const mobileArea = GameState.cacheElement('mobileArea');
    const joystickElement = GameState.cacheElement('virtualJoystick');
    const knobElement = GameState.cacheElement('joystickKnob');
    if (!mobileArea || !joystickElement || !knobElement) return;

    mobileArea.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = mobileArea.getBoundingClientRect();

      this.joystick.active = true;
      this.joystick.centerX = touch.clientX - rect.left;
      this.joystick.centerY = touch.clientY - rect.top;
      this.joystick.knobX = this.joystick.centerX;
      this.joystick.knobY = this.joystick.centerY;

      joystickElement.style.left = (this.joystick.centerX - this.joystick.radius) + 'px';
      joystickElement.style.top = (this.joystick.centerY - this.joystick.radius) + 'px';
      joystickElement.style.display = 'block';

      knobElement.style.left = '50%';
      knobElement.style.top = '50%';
    }, { passive: false });

    mobileArea.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!this.joystick.active) return;

      const touch = e.touches[0];
      const rect = mobileArea.getBoundingClientRect();
      const touchX = touch.clientX - rect.left;
      const touchY = touch.clientY - rect.top;

      const deltaX = touchX - this.joystick.centerX;
      const deltaY = touchY - this.joystick.centerY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

      if (distance <= this.joystick.radius - this.joystick.knobRadius) {
        this.joystick.knobX = touchX;
        this.joystick.knobY = touchY;
      } else {
        const angle = Math.atan2(deltaY, deltaX);
        const maxDistance = this.joystick.radius - this.joystick.knobRadius;
        this.joystick.knobX = this.joystick.centerX + Math.cos(angle) * maxDistance;
        this.joystick.knobY = this.joystick.centerY + Math.sin(angle) * maxDistance;
      }

      const knobOffsetX = this.joystick.knobX - this.joystick.centerX;
      const knobOffsetY = this.joystick.knobY - this.joystick.centerY;
      const knobPercX = 50 + (knobOffsetX / this.joystick.radius) * 50;
      const knobPercY = 50 + (knobOffsetY / this.joystick.radius) * 50;

      knobElement.style.left = knobPercX + '%';
      knobElement.style.top = knobPercY + '%';

      this.joystick.deltaX = knobOffsetX / (this.joystick.radius - this.joystick.knobRadius);
      this.joystick.deltaY = knobOffsetY / (this.joystick.radius - this.joystick.knobRadius);

      const threshold = 0.2;
      this.touchState = {
        left: this.joystick.deltaX < -threshold,
        right: this.joystick.deltaX > threshold,
        up: this.joystick.deltaY < -threshold,
        down: this.joystick.deltaY > threshold
      };
    }, { passive: false });

    mobileArea.addEventListener('touchend', (e) => {
      e.preventDefault();
      this.joystick.active = false;
      this.joystick.deltaX = 0;
      this.joystick.deltaY = 0;
      this.touchState = { left: false, right: false, up: false, down: false };

      joystickElement.style.display = 'none';

      knobElement.style.left = '50%';
      knobElement.style.top = '50%';
    }, { passive: false });
  },

  showControls() {
    if (!GameState.controlsVisible && GameState.running) {
      GameState.controlsVisible = true;
      const hud = GameState.cacheElement('hud');
      const pauseBtn = GameState.cacheElement('pauseBtn');
      if (hud) hud.style.display = 'flex';
      if (pauseBtn) pauseBtn.style.display = 'block';
    }
  },

  cleanup() {
    this.keys = {};
    this.touchState = { left: false, right: false, up: false, down: false };
    this.joystick.active = false;
    this.joystick.deltaX = 0;
    this.joystick.deltaY = 0;
  }
};

// Canvas Manager
const CanvasManager = {
  init() {
    GameState.canvas = document.getElementById('gameCanvas');
    if (!GameState.canvas) throw new Error('Canvas not found');

    GameState.ctx = GameState.canvas.getContext('2d', {
      alpha: false,
      antialias: CONFIG.CANVAS.ENABLE_ANTIALIASING,
      desynchronized: true
    });
    if (!GameState.ctx) throw new Error('Canvas context not available');

    this.resizeCanvas();
    window.addEventListener('resize', this.resizeCanvas.bind(this));
  },

  resizeCanvas() {
    GameState.width = window.innerWidth;
    GameState.height = window.innerHeight;

    if (!GameState.canvas || !GameState.ctx) return;

    const dpr = GameState.devicePixelRatio;
    GameState.canvas.width = GameState.width * dpr;
    GameState.canvas.height = GameState.height * dpr;
    GameState.canvas.style.width = GameState.width + 'px';
    GameState.canvas.style.height = GameState.height + 'px';

    GameState.ctx.setTransform(1, 0, 0, 1, 0, 0);
    GameState.ctx.scale(dpr, dpr);
    GameState.ctx.imageSmoothingEnabled = CONFIG.CANVAS.ENABLE_ANTIALIASING;
    GameState.ctx.imageSmoothingQuality = 'high';

    if (GameState.running) {
      Player.repositionOnResize();
    }
  }
};

// Game Manager
const GameManager = {
  init() {
    try {
      CanvasManager.init();
      InputManager.init();
    } catch (e) {
      console.error('Game initialization failed:', e);
    }
  },

  startGame() {
    document.getElementById('gameCanvas').style.display = 'block';
    document.getElementById('menuScreen').style.display = 'none';

    const hud = GameState.cacheElement('hud');
    const pauseBtn = GameState.cacheElement('pauseBtn');
    if (hud) hud.style.display = 'flex';
    if (pauseBtn) pauseBtn.style.display = 'block';

    if (GameState.isMobile) {
      const mobileArea = GameState.cacheElement('mobileArea');
      if (mobileArea) mobileArea.style.display = 'block';
    }

    this.initGame();
  },

  togglePauseSensitivity() {
    const control = document.getElementById('sensitivityControl');
    if (!control) return;

    if (control.style.display === 'flex' || control.style.display === 'block') {
      control.style.display = 'none';
    } else {
      control.style.display = 'flex';
      SensitivityManager.init();
    }
  },

  initGame() {
    GameState.reset();
    Player.reset();
    Player.setInitialPosition();
    GameObjects.clear();
    ParticleSystem.clear();
    WakeTrailSystem.clear();

    GameState.running = true;
    GameState.lastTime = performance.now();
    requestAnimationFrame(this.gameLoop.bind(this));
  },

  gameLoop(timestamp) {
    if (!GameState.running) return;

    const deltaTime = Math.min((timestamp - GameState.lastTime) / 1000, 0.05);
    GameState.lastTime = timestamp;

    if (!GameState.paused) {
      this.update(deltaTime);
    }

    Renderer.render();
    requestAnimationFrame(this.gameLoop.bind(this));
  },

  update(deltaTime) {
    GameState.oceanTime += deltaTime;
    const sailEfficiency = Utils.clamp(Player.sails / 100, CONFIG.PLAYER.MIN_EFFICIENCY, 1);
    GameState.distance += 120 * deltaTime * sailEfficiency;

    SeasonSystem.update();
    Player.update(deltaTime, InputManager.keys, InputManager.touchState);
    GameObjects.update(deltaTime);
    CollisionSystem.checkCollisions();
    ParticleSystem.update(deltaTime);
    WakeTrailSystem.update(deltaTime);

    if (GameState.shakeTime > 0) {
      GameState.shakeTime = Math.max(0, GameState.shakeTime - deltaTime);
    }

    if (GameState.combo > 1) {
      GameState.comboTimer = Math.max(0, GameState.comboTimer - deltaTime);
      if (GameState.comboTimer <= 0) {
        GameState.combo = 0;
        const indicator = GameState.cacheElement('comboIndicator');
        if (indicator) indicator.style.display = 'none';
      }
    }

    HudManager.update();

    if (Player.hull <= 0 || Player.fuel <= 0) {
      this.endGame();
    }
  },

  togglePause() {
    GameState.paused = !GameState.paused;
    const pauseScreen = GameState.cacheElement('pauseScreen');
    if (pauseScreen) {
      pauseScreen.style.display = GameState.paused ? 'flex' : 'none';
    }

    if (GameState.paused) {
      const control = document.getElementById('sensitivityControl');
      if (control) control.style.display = 'none';
    } else {
      const control = document.getElementById('sensitivityControl');
      if (control) control.style.display = 'none';
    }
  },

  restartGame() {
    ['gameOverScreen', 'pauseScreen'].forEach(id => {
      const element = GameState.cacheElement(id);
      if (element) element.style.display = 'none';
    });
    this.startGame();
  },

  returnToMenu() {
    GameState.running = false;
    const elementsToHide = ['gameOverScreen', 'pauseScreen', 'gameCanvas', 'hud', 'pauseBtn', 'comboIndicator', 'mobileArea', 'virtualJoystick', 'performanceIndicator'];
    elementsToHide.forEach(id => {
      const element = GameState.cacheElement(id);
      if (element) element.style.display = 'none';
    });
    document.getElementById('menuScreen').style.display = 'flex';
    const control = document.getElementById('sensitivityControl');
    if (control) control.style.display = 'none';
  },

  endGame() {
    GameState.running = false;

    const distance = Math.max(0, Math.floor(GameState.distance / 1000)) + ' km';
    const crashes = Math.max(0, GameState.crashes);
    const seasonIndex = Utils.clamp(GameState.season, 0, CONFIG.SEASONS.NAMES.length - 1);
    const distanceKm = GameState.distance / 1000;

    const season = distanceKm >= CONFIG.SEASONS.STORM_DISTANCE_KM ? 'STORM' : CONFIG.SEASONS.NAMES[seasonIndex];

    const updates = [
      { id: 'finalDistance', value: distance },
      { id: 'finalCrashes', value: crashes },
      { id: 'finalSeason', value: season }
    ];

    updates.forEach(({ id, value }) => {
      const element = GameState.cacheElement(id);
      if (element) element.textContent = value;
    });

    document.getElementById('gameOverScreen').style.display = 'flex';
  }
};

// Initialize when page loads
window.addEventListener('load', () => {
  GameManager.init();
});
</script>
</body>
</html>
