<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
<title>Ocean's Edge</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: fixed;
    -webkit-overflow-scrolling: touch;
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial;
       background:#001122;overflow:hidden;height:100vh;height:100dvh;user-select:none;touch-action:none}
  #gameContainer{position:relative;width:100vw;width:100dvw;height:100vh;height:100dvh;overflow:hidden}
  #gameCanvas{display:block;width:100%;height:100%;object-fit:cover}
  .ocean-waves,.floating-waves{position:absolute;inset:0;pointer-events:none}
  .ocean-waves{
    background:
      radial-gradient(circle at 20% 80%, rgba(135,206,235,.25) 0%, transparent 50%),
      radial-gradient(circle at 80% 20%, rgba(70,130,180,.18) 0%, transparent 50%),
      radial-gradient(circle at 40% 40%, rgba(25,25,112,.08) 0%, transparent 50%);
    animation:oceanWaves 6s ease-in-out infinite; z-index:1
  }
  @keyframes oceanWaves{0%,100%{transform:translateY(0) scale(1);opacity:.65}
                        50%{transform:translateY(-15px) scale(1.02);opacity:.95}}
  .floating-waves{
    background:linear-gradient(90deg,transparent 0%, rgba(255,255,255,.08) 50%, transparent 100%);
    animation:floatingWaves 8s linear infinite; z-index:2
  }
  @keyframes floatingWaves{0%{transform:translateX(-100%)}100%{transform:translateX(100%)}}

  #hud{position:absolute;top:0;left:0;right:0;z-index:5;
       color:#fff;padding:10px 20px;
       display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start;
       font-weight:600;font-size:14px;
       background:transparent;border:none}
  
  .hud-top{display:flex;align-items:center;gap:25px;margin-bottom:10px}
  .hud-bottom{display:flex;align-items:center;gap:20px}
  .hud-stat{display:flex;align-items:center;gap:8px}
  .hud-label{font-size:14px;opacity:.8;font-weight:500}
  .hud-value{font-size:16px;font-weight:600;text-shadow:1px 1px 2px rgba(0,0,0,0.5)}
  
  .progress-mini{width:80px;height:6px;border-radius:3px;overflow:hidden;
                 background:rgba(0,0,0,.4);position:relative;
                 border:1px solid rgba(255,255,255,.3);
                 box-shadow:none}
  .hull-fill{height:100%;background:linear-gradient(90deg,#ff4444,#44ff44);
             transition:width .4s ease;border-radius:3px;
             box-shadow:none}
  .fuel-fill{height:100%;background:linear-gradient(90deg,#ff8800,#ffdd00);
             transition:width .4s ease;border-radius:3px;
             box-shadow:none}
  .season-indicator{display:inline-block;font-weight:700;font-size:14px;padding:6px 12px;border-radius:20px;
                    transition:all 0.5s ease}
  .summer{background:linear-gradient(45deg,#ffeb3b,#ffc107);color:#333}
  .autumn{background:linear-gradient(45deg,#ff9800,#ff5722);color:#fff}
  .winter{background:linear-gradient(45deg,#2196f3,#03a9f4);color:#fff}
  .storm{background:linear-gradient(45deg,#9c27b0,#673ab7);color:#fff}

  .pause-btn{position:absolute;top:10px;right:10px;z-index:6;
             background:rgba(0,20,40,.9);color:#fff;padding:8px 12px;border-radius:8px;
             border:2px solid rgba(135,206,235,.4);cursor:pointer;
             font-size:14px;font-weight:600;transition:all .2s ease}
  .pause-btn:hover{background:rgba(70,130,180,.8);transform:translateY(-1px)}

  #menuScreen,#gameOverScreen,#pauseScreen{position:absolute;inset:0;display:flex;flex-direction:column;
      align-items:center;justify-content:center;color:#fff;text-align:center;z-index:6}
  #menuScreen{background:linear-gradient(180deg,#001122 0%,#003366 50%,#004488 100%)}
  #gameOverScreen,#pauseScreen{display:none;background:rgba(0,17,34,.95);backdrop-filter:blur(10px)}
  .title{font-size:4rem;font-weight:900;color:#87CEEB;text-shadow:3px 3px 6px rgba(0,0,0,.8);margin-bottom:14px}
  .subtitle{max-width:700px;color:#B0C4DE;line-height:1.6;margin:0 20px 36px}
  .game-btn{background:linear-gradient(45deg,#9b59b6,#6bb6ff);color:#fff;border:0;padding:14px 28px;
            border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(155,89,182,.35);
            transition:transform .15s ease, box-shadow .15s ease;margin:5px}
  .game-btn:hover{transform:translateY(-2px);box-shadow:0 10px 26px rgba(155,89,182,.45)}
  .controls{margin-top:22px;color:#B0C4DE}

  .shake{animation:shake .28s ease-in-out}
  @keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}

  .combo-indicator{position:absolute;top:150px;right:20px;z-index:5;
                   background:rgba(255,215,0,.2);color:#ffd700;padding:10px 15px;border-radius:10px;
                   border:2px solid rgba(255,215,0,.5);backdrop-filter:blur(10px);
                   font-weight:bold;font-size:14px;display:none;animation:pulse 1s infinite}
  @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.05)}}

  .season-transition{position:absolute;inset:0;z-index:4;pointer-events:none;
                     background:radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
                     opacity:0;animation:seasonFlash 1s ease-out}
  @keyframes seasonFlash{0%{opacity:0}30%{opacity:1}100%{opacity:0}}

  /* Mobile touch controls - invisible screen areas */
  .mobile-touch-area{position:absolute;top:0;width:50%;height:100%;z-index:3;
                     user-select:none;touch-action:none;opacity:0}
  .mobile-touch-left{left:0}
  .mobile-touch-right{right:0}

  @media (max-width: 768px) {
    .title{font-size:2.5rem}
    .subtitle{font-size:14px}
    .hud-label{font-size:13px}
    .hud-value{font-size:15px}
    .pause-btn{display:block !important}
  }
  
  /* Additional mobile-specific fixes */
  @media screen and (max-width: 480px) {
    .title{font-size:2rem}
    .hud-top{gap:15px}
    .hud-bottom{gap:15px}
    .progress-mini{width:60px}
  }
  
  /* Fix for very tall screens */
  @media screen and (min-aspect-ratio: 9/16) and (max-width: 480px) {
    #gameContainer {
      height: 100vh;
      height: 100dvh;
    }
  }
</style>
</head>
<body>
<div id="gameContainer">
  <div class="ocean-waves"></div>
  <div class="floating-waves"></div>

  <!-- Main Menu -->
  <div id="menuScreen">
    <h1 class="title">Ocean's Edge</h1>
    <p class="subtitle">
      Navigate treacherous waters in your sailing ship. Collect fuel and repair kits while avoiding enemy ships.
      Seasons raise the stakes — survive for the highest score.
    </p>
    <button class="game-btn" onclick="startGame()">Set Sail</button>
    <div class="controls">Use ← → arrow keys to steer • SPACE to pause<br><small>Touch controls available on mobile</small></div>
  </div>

  <canvas id="gameCanvas" style="display:none"></canvas>

  <!-- HUD -->
  <div id="hud" style="display:none">
    <div class="hud-top">
      <div class="hud-stat">
        <span class="hud-label">Distance:</span>
        <span class="hud-value" id="distance">0km</span>
      </div>
      <div class="hud-stat">
        <span class="hud-label">Score:</span>
        <span class="hud-value" id="score">0</span>
      </div>
      <div class="hud-stat">
        <span id="season" class="season-indicator summer">Summer</span>
      </div>
    </div>
    
    <div class="hud-bottom">
      <div class="hud-stat">
        <span class="hud-label">Health:</span>
        <div class="progress-mini">
          <div id="hullBar" class="hull-fill" style="width:100%"></div>
        </div>
        <span class="hud-value" id="hullPercent">100%</span>
      </div>
      <div class="hud-stat">
        <span class="hud-label">Fuel:</span>
        <div class="progress-mini">
          <div id="fuelBar" class="fuel-fill" style="width:100%"></div>
        </div>
        <span class="hud-value" id="fuelPercent">100%</span>
      </div>
    </div>
  </div>

  <!-- Mobile Touch Areas (invisible) -->
  <div class="mobile-touch-area mobile-touch-left" id="mobileLeftArea" style="display:none"></div>
  <div class="mobile-touch-area mobile-touch-right" id="mobileRightArea" style="display:none"></div>

  <!-- Menu Button -->
  <div class="pause-btn" id="pauseBtn" style="display:none" onclick="togglePause()">☰</div>

  <!-- Combo Indicator -->
  <div class="combo-indicator" id="comboIndicator">
    <div>COMBO x<span id="comboCount">2</span></div>
    <div style="font-size:12px">+<span id="comboBonus">100</span> bonus!</div>
  </div>

  <!-- Pause Screen -->
  <div id="pauseScreen">
    <h2 class="title" style="font-size:3rem">Paused</h2>
    <div style="display:flex;gap:15px;margin-top:25px;align-items:center;justify-content:center">
      <button class="game-btn" onclick="togglePause()">Resume</button>
      <button class="game-btn" onclick="restartGame()">Restart</button>
      <button class="game-btn" onclick="returnToMenu()">Exit</button>
    </div>
  </div>

  <!-- Game Over -->
  <div id="gameOverScreen">
    <h2 class="title" style="font-size:3rem;color:#ff6b6b">Game Over</h2>
    <p style="margin:8px 0">Distance: <b id="finalDistance">0 km</b></p>
    <p style="margin:8px 0">Final Score: <b id="finalScore">0</b></p>
    <p style="margin:8px 0">Season Reached: <b id="finalSeason">Summer</b></p>
    <div style="display:flex;gap:10px;margin-top:18px">
      <button class="game-btn" onclick="restartGame()">Play Again</button>
      <button class="game-btn" onclick="returnToMenu()">Main Menu</button>
    </div>
  </div>
</div>

<script>
/* ------------ Game Constants ------------ */
const CONFIG = {
  PLAYER: {
    SPEED: 7,
    WIDTH: 36,
    HEIGHT: 56,
    HULL_DECAY: 0.6,
    FUEL_DECAY: 1.0,
    SAILS_DECAY: 0.3
  },
  SPAWN: {
    OBSTACLE_BASE_CHANCE: 0.012,
    ITEM_BASE_CHANCE: 0.008
  },
  COMBO: {
    DURATION: 3,
    MULTIPLIER: 0.5
  },
  AUDIO: {
    MASTER_VOLUME: 0.08
  },
  OCEAN: {
    WAVE_LAYERS: 12,
    FOAM_PARTICLES: 8,
    DEPTH_LAYERS: 6
  }
};

/* ------------ Core state ------------ */
const game = {
  canvas:null, ctx:null, width:0, height:0,
  running:false, paused:false, lastTime:0,
  distance:0, score:0,
  season:0,
  seasonNames:['Summer','Autumn','Winter','Storm'],
  seasonClasses:['summer','autumn','winter','storm'],
  seasonMultipliers:[1,1.5,2.5,4],
  seasonThresholds:[0,3000,7000,12000],
  shakeTime:0,
  combo:0, comboTimer:0,
  isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
  lastObstacleSpawn: 0,
  lastItemSpawn: 0,
  oceanTime: 0,
  devicePixelRatio: window.devicePixelRatio || 1,
  initialPlayerY: 0
};

const player = {
  x:0, y:0, 
  width:CONFIG.PLAYER.WIDTH, 
  height:CONFIG.PLAYER.HEIGHT,
  speed:CONFIG.PLAYER.SPEED,
  hull:100, fuel:100, sails:100,
  hullDecay:CONFIG.PLAYER.HULL_DECAY, 
  fuelDecay:CONFIG.PLAYER.FUEL_DECAY, 
  sailsDecay:CONFIG.PLAYER.SAILS_DECAY,
  bobOffset: 0,
  wakeTrail: []
};

let obstacles=[], items=[], keys={}, particles=[], touchState={left:false,right:false};
let waterDroplets = [];
let audioContext=null, audioInitialized=false;
let mobileEventListeners = [];

/* ------------ Audio system ------------ */
function initAudio(){ 
  if(audioInitialized || audioContext) return;
  try{ 
    audioContext = new (window.AudioContext||window.webkitAudioContext)(); 
    
    if(audioContext.state === 'suspended') {
      const resumeAudio = () => {
        if(audioContext && audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            audioInitialized = true;
          }).catch(e => console.warn('Audio resume failed:', e));
        }
        document.removeEventListener('touchstart', resumeAudio);
        document.removeEventListener('click', resumeAudio);
      };
      
      document.addEventListener('touchstart', resumeAudio);
      document.addEventListener('click', resumeAudio);
    } else {
      audioInitialized = true;
    }
  }catch(e){ 
    console.warn('Audio not available:', e); 
    audioContext = null;
  } 
}

function beep(frequency=440, duration=120, type='sine', volume=1){
  if(!audioContext || !audioInitialized) return;
  try{
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.type = type;
    oscillator.frequency.value = frequency;
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    const vol = CONFIG.AUDIO.MASTER_VOLUME * volume;
    gainNode.gain.setValueAtTime(vol, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration/1000);
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + duration/1000);
  }catch(e){ console.warn('Audio error:', e); }
}

/* ------------ Setup / lifecycle ------------ */
function startGame(){
  initAudio();
  document.getElementById('menuScreen').style.display='none';
  document.getElementById('gameCanvas').style.display='block';
  document.getElementById('hud').style.display='flex';
  document.getElementById('pauseBtn').style.display='block';
  
  if(game.isMobile){
    document.getElementById('mobileLeftArea').style.display='block';
    document.getElementById('mobileRightArea').style.display='block';
    setupMobileControls();
  }
  
  initGame();
}

function setupMobileControls(){
  const leftArea = document.getElementById('mobileLeftArea');
  const rightArea = document.getElementById('mobileRightArea');
  
  const leftTouchStart = (e) => {
    e.preventDefault(); 
    touchState.left = true;
  };
  const leftTouchEnd = (e) => {
    e.preventDefault(); 
    touchState.left = false;
  };
  const rightTouchStart = (e) => {
    e.preventDefault(); 
    touchState.right = true;
  };
  const rightTouchEnd = (e) => {
    e.preventDefault(); 
    touchState.right = false;
  };
  const preventMove = (e) => e.preventDefault();
  
  leftArea.addEventListener('touchstart', leftTouchStart);
  leftArea.addEventListener('touchend', leftTouchEnd);
  rightArea.addEventListener('touchstart', rightTouchStart);
  rightArea.addEventListener('touchend', rightTouchEnd);
  document.addEventListener('touchmove', preventMove, {passive: false});
  
  mobileEventListeners = [
    {element: leftArea, event: 'touchstart', handler: leftTouchStart},
    {element: leftArea, event: 'touchend', handler: leftTouchEnd},
    {element: rightArea, event: 'touchstart', handler: rightTouchStart},
    {element: rightArea, event: 'touchend', handler: rightTouchEnd},
    {element: document, event: 'touchmove', handler: preventMove}
  ];
}

function togglePause(){
  game.paused = !game.paused;
  document.getElementById('pauseScreen').style.display = game.paused ? 'flex' : 'none';
}

function initGame(){
  game.canvas = document.getElementById('gameCanvas');
  game.ctx = game.canvas.getContext('2d');
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('orientationchange', () => {
    setTimeout(resizeCanvas, 100);
  });

  Object.assign(game, {
    distance:0, score:0, season:0, shakeTime:0, 
    combo:0, comboTimer:0, paused:false,
    lastObstacleSpawn:0, lastItemSpawn:0, oceanTime:0
  });
  
  setInitialPlayerPosition();
  Object.assign(player, {hull:100, fuel:100, sails:100, bobOffset:0});
  player.wakeTrail = [];
  
  obstacles.length = 0;
  items.length = 0;
  particles.length = 0;
  waterDroplets.length = 0;

  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);

  game.running = true;
  game.lastTime = performance.now();
  requestAnimationFrame(gameLoop);
}

function setInitialPlayerPosition() {
  const bottomMargin = Math.max(30, game.height * 0.05);
  const sideMargin = Math.max(10, game.width * 0.02);
  
  player.x = Math.max(sideMargin, (game.width - player.width) / 2);
  player.y = Math.max(0, game.height - player.height - bottomMargin);
  
  game.initialPlayerY = player.y;
  
  player.x = Math.min(player.x, game.width - player.width - sideMargin);
  
  console.log('Player positioned at:', player.x, player.y, 'Screen:', game.width, game.height);
}

function repositionPlayerOnResize() {
  const bottomMargin = Math.max(30, game.height * 0.05);
  const sideMargin = Math.max(10, game.width * 0.02);
  
  const centerX = (game.width - player.width) / 2;
  if(centerX >= sideMargin && centerX <= game.width - player.width - sideMargin) {
    player.x = centerX;
  } else {
    player.x = Math.max(sideMargin, Math.min(player.x, game.width - player.width - sideMargin));
  }
  
  const newY = game.height - player.height - bottomMargin;
  player.y = Math.max(0, newY);
  
  player.x = Math.max(0, Math.min(player.x, game.width - player.width));
  player.y = Math.max(0, Math.min(player.y, game.height - player.height));
  
  console.log('Player repositioned to:', player.x, player.y, 'Screen:', game.width, game.height);
}

function restartGame(){
  cleanup();
  document.getElementById('gameOverScreen').style.display='none';
  document.getElementById('pauseScreen').style.display='none';
  startGame();
}

function returnToMenu(){
  cleanup();
  const elementsToHide = ['gameOverScreen', 'pauseScreen', 'gameCanvas', 'hud', 'pauseBtn', 'comboIndicator', 'mobileLeftArea', 'mobileRightArea'];
  elementsToHide.forEach(id => document.getElementById(id).style.display='none');
  document.getElementById('menuScreen').style.display='flex';
}

function cleanup(){
  game.running = false;
  document.removeEventListener('keydown', onKeyDown);
  document.removeEventListener('keyup', onKeyUp);
  window.removeEventListener('resize', resizeCanvas);
  window.removeEventListener('orientationchange', resizeCanvas);
  
  mobileEventListeners.forEach(({element, event, handler}) => {
    element.removeEventListener(event, handler);
  });
  mobileEventListeners = [];
  
  if(audioContext && audioContext.state !== 'closed') {
    try {
      audioContext.close();
      audioContext = null;
      audioInitialized = false;
    } catch(e) {
      console.warn('Error closing audio context:', e);
    }
  }
}

function onKeyDown(e){
  keys[e.code] = true;
  if(e.code === 'Space'){
    e.preventDefault();
    togglePause();
  }
  if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.code)) {
    e.preventDefault();
  }
}

function onKeyUp(e){ 
  keys[e.code] = false; 
}

function resizeCanvas(){
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  
  game.width = Math.max(320, viewportWidth); 
  game.height = Math.max(480, viewportHeight);
  
  if(!game.canvas) return;
  
  game.canvas.style.width = viewportWidth + 'px';
  game.canvas.style.height = viewportHeight + 'px';
  
  const dpr = game.devicePixelRatio;
  game.canvas.width = viewportWidth * dpr;
  game.canvas.height = viewportHeight * dpr;
  
  if(game.ctx) {
    game.ctx.scale(dpr, dpr);
  }
  
  game.width = viewportWidth;
  game.height = viewportHeight;
  
  if(game.running){
    repositionPlayerOnResize();
  }
}

/* ------------ Game Loop ------------ */
function gameLoop(timestamp){
  if(!game.running) return;
  
  const deltaTime = Math.min(0.05, Math.max(0.0001, (timestamp - game.lastTime) / 1000));
  game.lastTime = timestamp;

  if(!game.paused){
    update(deltaTime);
  }
  render();
  requestAnimationFrame(gameLoop);
}

/* ------------ Update Logic ------------ */
function update(deltaTime){
  game.oceanTime += deltaTime;
  
  const sailEfficiency = Math.max(0.3, player.sails / 100);
  game.distance += 120 * deltaTime * sailEfficiency;

  updateSeason();
  updatePlayer(deltaTime, sailEfficiency);
  updateOceanEffects(deltaTime);
  updateSystems(deltaTime);
  
  if(player.hull <= 0 || player.fuel <= 0){ 
    endGame(); 
    return; 
  }

  spawnObjects(deltaTime);
  updateGameObjects(deltaTime);
  checkCollisions();
  updateScore();
  updateHUD();
}

function updateOceanEffects(deltaTime) {
  for(let i = waterDroplets.length - 1; i >= 0; i--) {
    const drop = waterDroplets[i];
    drop.x += drop.vx * deltaTime;
    drop.y += drop.vy * deltaTime;
    drop.vy += 150 * deltaTime;
    drop.life -= deltaTime;
    drop.alpha = Math.max(0, drop.life / drop.maxLife);
    
    if(drop.life <= 0 || drop.y > game.height + 50) {
      waterDroplets.splice(i, 1);
    }
  }
  
  if(waterDroplets.length > 100) {
    waterDroplets.splice(0, waterDroplets.length - 100);
  }
  
  if(player.wakeTrail.length > 20) {
    player.wakeTrail.shift();
  }
  player.wakeTrail.push({
    x: player.x + player.width/2,
    y: player.y + player.height,
    age: 0
  });
  
  player.wakeTrail.forEach(wake => wake.age += deltaTime);
  
  player.bobOffset = Math.sin(game.oceanTime * 2.5) * 3 + Math.sin(game.oceanTime * 1.8) * 1.5;
}

function createWaterDroplets(x, y, count = 5) {
  for(let i = 0; i < count; i++) {
    waterDroplets.push({
      x: x + (Math.random() - 0.5) * 30,
      y: y + (Math.random() - 0.5) * 20,
      vx: (Math.random() - 0.5) * 100,
      vy: -50 - Math.random() * 100,
      life: 0.8 + Math.random() * 0.7,
      maxLife: 0.8 + Math.random() * 0.7,
      alpha: 1,
      size: 2 + Math.random() * 4
    });
  }
}

function updateSeason(){
  const newSeason = game.seasonThresholds.findIndex((threshold, i) => 
    i === game.seasonThresholds.length - 1 || game.distance < game.seasonThresholds[i + 1]
  );
  
  if(newSeason !== game.season && newSeason >= 0){
    game.season = newSeason;
    beep(220 + newSeason * 120, 200, 'triangle');
    createParticles(player.x + player.width/2, player.y, '#ffffaa', 15);
    showSeasonTransition();
  }
}

function showSeasonTransition(){
  const transition = document.createElement('div');
  transition.className = 'season-transition';
  document.getElementById('gameContainer').appendChild(transition);
  setTimeout(() => transition.remove(), 1000);
}

function updatePlayer(deltaTime, sailEfficiency){
  const moveSpeed = player.speed * (0.5 + sailEfficiency * 0.5);
  
  if(keys['ArrowLeft'] || touchState.left) {
    player.x -= moveSpeed;
    if(Math.random() < 0.3) {
      createWaterDroplets(player.x, player.y + player.height/2, 2);
    }
  }
  if(keys['ArrowRight'] || touchState.right) {
    player.x += moveSpeed;
    if(Math.random() < 0.3) {
      createWaterDroplets(player.x + player.width, player.y + player.height/2, 2);
    }
  }
  
  const sideMargin = Math.max(5, game.width * 0.01);
  player.x = Math.max(sideMargin, Math.min(player.x, game.width - player.width - sideMargin));

  const bottomMargin = Math.max(30, game.height * 0.05);
  const maxY = game.height - player.height - bottomMargin;
  if(player.y < maxY * 0.7) {
    player.y = maxY;
  }

  const decayMultiplier = 1 + game.season * 0.3;
  player.hull = Math.max(0, player.hull - player.hullDecay * deltaTime * decayMultiplier);
  player.fuel = Math.max(0, player.fuel - player.fuelDecay * deltaTime * decayMultiplier);
  player.sails = Math.max(0, player.sails - player.sailsDecay * deltaTime * decayMultiplier);
}

function updateSystems(deltaTime){
  if(game.shakeTime > 0) game.shakeTime -= deltaTime;

  if(game.combo > 1){
    game.comboTimer -= deltaTime;
    if(game.comboTimer <= 0){
      game.combo = 0;
      document.getElementById('comboIndicator').style.display = 'none';
    }
  }
}

function spawnObjects(deltaTime){
  const seasonMultiplier = 1 + game.season * 0.7;
  const currentTime = performance.now();
  
  if(currentTime - game.lastObstacleSpawn > (800 / seasonMultiplier)){
    if(Math.random() < CONFIG.SPAWN.OBSTACLE_BASE_CHANCE * seasonMultiplier){
      spawnObstacle();
      game.lastObstacleSpawn = currentTime;
    }
  }
  
  if(currentTime - game.lastItemSpawn > 1200){
    if(Math.random() < CONFIG.SPAWN.ITEM_BASE_CHANCE){
      spawnItem();
      game.lastItemSpawn = currentTime;
    }
  }
}

function spawnObstacle(){
  const size = 35 + Math.random() * 20;
  
  obstacles.push({
    x: Math.random() * (game.width - size),
    y: -60,
    width: size,
    height: size * 1.2,
    speed: 2 + game.season * 1.1 + Math.random() * 1.8,
    type: 'enemyShip',
    rotation: 0,
    rotationSpeed: 0,
    wakeTrail: []
  });
}

function spawnItem(){
  items.push({
    x: Math.random() * (game.width - 26),
    y: -26,
    width: 26,
    height: 26,
    speed: 1.6 + game.season * 0.6,
    type: Math.random() < 0.5 ? 'fuel' : 'repair',
    bobOffset: Math.random() * Math.PI * 2,
    sparkleTime: 0
  });
}

function updateGameObjects(deltaTime){
  for(let i = obstacles.length - 1; i >= 0; i--){
    const obstacle = obstacles[i];
    obstacle.y += obstacle.speed;
    obstacle.rotation += obstacle.rotationSpeed * deltaTime;
    
    if(obstacle.wakeTrail.length > 10) {
      obstacle.wakeTrail.shift();
    }
    obstacle.wakeTrail.push({
      x: obstacle.x + obstacle.width/2,
      y: obstacle.y + obstacle.height,
      age: 0
    });
    obstacle.wakeTrail.forEach(wake => wake.age += deltaTime);
    
    if(obstacle.y > game.height + 100){
      obstacles.splice(i, 1);
    }
  }
  
  for(let i = items.length - 1; i >= 0; i--){
    const item = items[i];
    item.y += item.speed;
    item.sparkleTime += deltaTime;
    
    if(item.y > game.height + 50){
      items.splice(i, 1);
    }
  }
  
  updateParticles(deltaTime);
}

function updateParticles(deltaTime){
  for(let i = particles.length - 1; i >= 0; i--){
    const particle = particles[i];
    particle.x += particle.vx * deltaTime;
    particle.y += particle.vy * deltaTime;
    particle.life -= deltaTime;
    particle.alpha = Math.max(0, particle.life / particle.maxLife);
    
    if(particle.life <= 0){
      particles.splice(i, 1);
    }
  }
  
  if(particles.length > 150) {
    particles.splice(0, particles.length - 150);
  }
}

function createParticles(x, y, color, count = 8){
  for(let i = 0; i < count; i++){
    particles.push({
      x: x + (Math.random() - 0.5) * 20,
      y: y + (Math.random() - 0.5) * 20,
      vx: (Math.random() - 0.5) * 150,
      vy: (Math.random() - 0.5) * 150,
      color,
      life: 0.6 + Math.random() * 0.4,
      maxLife: 0.6 + Math.random() * 0.4,
      alpha: 1,
      size: 2 + Math.random() * 4
    });
  }
}

function aabb(a, b){
  return a.x < b.x + b.width && 
         a.x + a.width > b.x && 
         a.y < b.y + b.height && 
         a.y + a.height > b.y;
}

function checkCollisions(){
  for(let i = obstacles.length - 1; i >= 0; i--){
    const obstacle = obstacles[i];
    if(aabb(player, obstacle)){
      obstacles.splice(i, 1);
      handleObstacleHit(obstacle);
    }
  }
  
  for(let i = items.length - 1; i >= 0; i--){
    const item = items[i];
    if(aabb(player, item)){
      items.splice(i, 1);
      handleItemCollection(item);
    }
  }
}

function handleObstacleHit(obstacle){
  game.combo = 0;
  document.getElementById('comboIndicator').style.display = 'none';
  
  player.hull -= 22;
  
  beep(160, 280, 'sawtooth');
  createParticles(
    obstacle.x + obstacle.width/2, 
    obstacle.y + obstacle.height/2, 
    '#ff4444', 
    12
  );
  
  createWaterDroplets(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, 15);
  
  triggerScreenShake();
}

function handleItemCollection(item){
  game.combo++;
  game.comboTimer = CONFIG.COMBO.DURATION;
  
  const baseBonus = item.type === 'fuel' ? 50 : 75;
  const comboBonus = baseBonus * (game.combo - 1);
  game.score += comboBonus;
  
  if(game.combo > 1){
    document.getElementById('comboCount').textContent = game.combo;
    document.getElementById('comboBonus').textContent = comboBonus;
    document.getElementById('comboIndicator').style.display = 'block';
  }
  
  if(item.type === 'fuel'){
    player.fuel = Math.min(100, player.fuel + 30);
    beep(420, 140, 'sine');
    createParticles(item.x + item.width/2, item.y + item.height/2, '#ff9900', 10);
  } else {
    player.hull = Math.min(100, player.hull + 35);
    player.sails = Math.min(100, player.sails + 20);
    beep(520, 140, 'sine');
    createParticles(item.x + item.width/2, item.y + item.height/2, '#32cd32', 10);
  }
  
  createWaterDroplets(item.x + item.width/2, item.y + item.height/2, 3);
}

function triggerScreenShake(){
  game.shakeTime = 0.28;
  const gameContainer = document.getElementById('gameContainer');
  gameContainer.classList.add('shake');
  setTimeout(() => gameContainer.classList.remove('shake'), 280);
}

function updateScore(){
  const comboMultiplier = game.combo > 1 ? 1 + (game.combo - 1) * CONFIG.COMBO.MULTIPLIER : 1;
  game.score = Math.floor(game.distance * game.seasonMultipliers[game.season] * comboMultiplier);
}

function render(){
  const ctx = game.ctx;
  
  if(game.shakeTime > 0){
    ctx.save();
    const intensity = game.shakeTime * 15;
    ctx.translate(
      (Math.random() - 0.5) * intensity,
      (Math.random() - 0.5) * intensity
    );
  }

  renderRealisticOcean(ctx);
  renderPlayer(ctx);
  renderObstacles(ctx);
  renderItems(ctx);
  renderOceanEffects(ctx);
  renderParticles(ctx);

  if(game.shakeTime > 0) ctx.restore();
}

function renderRealisticOcean(ctx) {
  const gradient = ctx.createLinearGradient(0, 0, 0, game.height);
  
  const waterColorSets = [
    {
      surface: '#87CEEB',
      shallow: '#4682B4', 
      deep: '#191970',
      accent: '#20B2AA'
    },
    {
      surface: '#6B8DB5',
      shallow: '#2F4F4F',
      deep: '#1C3A3A',
      accent: '#4682B4'
    },
    {
      surface: '#B0C4DE',
      shallow: '#4682B4',
      deep: '#0F1B44',
      accent: '#87CEFA'
    },
    {
      surface: '#2F2F2F',
      shallow: '#1C1C1C',
      deep: '#000000',
      accent: '#4B0082'
    }
  ];
  
  const colors = waterColorSets[game.season];
  
  gradient.addColorStop(0, colors.surface);
  gradient.addColorStop(0.3, colors.shallow);
  gradient.addColorStop(0.7, colors.deep);
  gradient.addColorStop(1, colors.deep);
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, game.width, game.height);
  
  renderOceanFloor(ctx);
}

function renderOceanFloor(ctx) {
  const floorY = game.height * 0.85;
  const floorHeight = game.height - floorY;
  const time = game.oceanTime;
  
  ctx.save();
  ctx.globalAlpha = 0.1;
  
  const floorGradient = ctx.createLinearGradient(0, floorY, 0, game.height);
  floorGradient.addColorStop(0, 'transparent');
  floorGradient.addColorStop(0.3, 'rgba(139,126,102,0.3)');
  floorGradient.addColorStop(1, 'rgba(101,67,33,0.5)');
  
  ctx.fillStyle = floorGradient;
  ctx.fillRect(0, floorY, game.width, floorHeight);
  
  ctx.strokeStyle = 'rgba(34,139,34,0.4)';
  ctx.lineWidth = 2;
  
  for(let i = 0; i < 12; i++) {
    const x = (game.width / 12) * i + Math.sin(time + i) * 20;
    const height = 30 + Math.sin(time * 0.7 + i) * 15;
    
    ctx.beginPath();
    ctx.moveTo(x, game.height);
    ctx.quadraticCurveTo(
      x + Math.sin(time + i) * 10, 
      game.height - height/2,
      x + Math.sin(time * 1.2 + i) * 8, 
      game.height - height
    );
    ctx.stroke();
  }
  
  ctx.restore();
}

function renderOceanEffects(ctx) {
  waterDroplets.forEach(drop => {
    ctx.save();
    ctx.globalAlpha = drop.alpha;
    ctx.fillStyle = 'rgba(173,216,230,0.8)';
    
    ctx.beginPath();
    ctx.arc(drop.x, drop.y, drop.size, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.arc(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.4, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  });
  
  renderWakeTrail(ctx, player.wakeTrail, 'rgba(255,255,255,0.4)');
  
  obstacles.forEach(obstacle => {
    renderWakeTrail(ctx, obstacle.wakeTrail, 'rgba(50,50,50,0.3)');
  });
}

function renderWakeTrail(ctx, trail, color) {
  if(trail.length < 2) return;
  
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  
  ctx.beginPath();
  for(let i = 0; i < trail.length - 1; i++) {
    const wake = trail[i];
    const alpha = Math.max(0, 1 - wake.age / 2);
    
    ctx.save();
    ctx.globalAlpha = alpha;
    
    if(i === 0) {
      ctx.moveTo(wake.x, wake.y);
    } else {
      ctx.lineTo(wake.x, wake.y);
    }
    
    ctx.restore();
  }
  ctx.stroke();
  
  ctx.restore();
}

function renderPlayer(ctx){
  const playerY = player.y + player.bobOffset;
  drawPlayerShip(ctx, player.x, playerY, player.width, player.height);
}

function renderObstacles(ctx){
  obstacles.forEach(obstacle => {
    const bobbing = Math.sin(game.oceanTime * 2 + obstacle.x * 0.01) * 2;
    obstacle.renderY = obstacle.y + bobbing;
    drawEnemyShip(ctx, obstacle);
  });
}

function renderItems(ctx){
  items.forEach(item => {
    const bobOffset = Math.sin(item.sparkleTime * 3 + item.bobOffset) * 4;
    const waterBob = Math.sin(game.oceanTime * 2.5 + item.x * 0.02) * 1.5;
    drawItem(ctx, item, bobOffset + waterBob);
  });
}

function renderParticles(ctx){
  particles.forEach(particle => {
    ctx.save();
    ctx.globalAlpha = particle.alpha;
    ctx.fillStyle = particle.color;
    ctx.fillRect(
      particle.x - particle.size/2,
      particle.y - particle.size/2,
      particle.size,
      particle.size
    );
    ctx.restore();
  });
}

function drawPlayerShip(ctx, x, y, width, height){
  ctx.save();
  ctx.translate(x + width/2, y + height/2);

  const hullColor = player.hull > 75 ? '#f2f6ff' : 
                   player.hull > 50 ? '#f0f0e0' : 
                   player.hull > 25 ? '#e8e0d0' : '#d0c0b0';
  
  ctx.fillStyle = hullColor;
  ctx.beginPath();
  ctx.moveTo(0, -height * 0.55);
  ctx.quadraticCurveTo(width * 0.45, -height * 0.25, width * 0.38, height * 0.40);
  ctx.lineTo(-width * 0.38, height * 0.40);
  ctx.quadraticCurveTo(-width * 0.45, -height * 0.25, 0, -height * 0.55);
  ctx.closePath();
  ctx.fill();

  ctx.strokeStyle = 'rgba(70,130,180,0.6)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-width * 0.35, height * 0.35);
  ctx.lineTo(width * 0.35, height * 0.35);
  ctx.stroke();

  ctx.save();
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = hullColor;
  ctx.scale(1, -0.3);
  ctx.translate(0, -height * 1.4);
  ctx.beginPath();
  ctx.moveTo(0, -height * 0.55);
  ctx.quadraticCurveTo(width * 0.45, -height * 0.25, width * 0.38, height * 0.40);
  ctx.lineTo(-width * 0.38, height * 0.40);
  ctx.quadraticCurveTo(-width * 0.45, -height * 0.25, 0, -height * 0.55);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  ctx.strokeStyle = 'rgba(0,0,0,0.2)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-width * 0.32, height * 0.30);
  ctx.lineTo(width * 0.32, height * 0.30);
  ctx.stroke();

  ctx.fillStyle = '#c9d3e7';
  ctx.fillRect(-2, -height * 0.48, 4, height * 0.78);

  const sailAlpha = 0.85 * Math.max(0.25, player.sails / 100);
  const windEffect = Math.sin(game.oceanTime * 3) * 2;
  
  ctx.fillStyle = `rgba(255,255,255,${sailAlpha})`;
  
  ctx.beginPath();
  ctx.moveTo(0, -height * 0.45);
  ctx.quadraticCurveTo(width * 0.30 + windEffect, -height * 0.25, width * 0.30, -height * 0.05);
  ctx.lineTo(0, -height * 0.05);
  ctx.closePath();
  ctx.fill();
  
  ctx.beginPath();
  ctx.moveTo(0, -height * 0.35);
  ctx.quadraticCurveTo(-width * 0.28 - windEffect * 0.5, -height * 0.15, -width * 0.28, 0);
  ctx.lineTo(0, 0);
  ctx.closePath();
  ctx.fill();

  const wakeAlpha = 0.6 + Math.sin(game.oceanTime * 4) * 0.2;
  ctx.fillStyle = `rgba(255,255,255,${wakeAlpha})`;
  ctx.fillRect(-width * 0.22, height * 0.45, width * 0.44, 3);
  
  ctx.fillStyle = `rgba(255,255,255,${wakeAlpha * 0.7})`;
  ctx.fillRect(-width * 0.16, height * 0.50, width * 0.32, 2);
  ctx.fillRect(-width * 0.10, height * 0.55, width * 0.20, 1);

  if(player.hull < 50){
    ctx.fillStyle = player.hull < 25 ? '#ff3333' : '#ff9900';
    const damageCount = player.hull < 25 ? 4 : 2;
    for(let i = 0; i < damageCount; i++){
      const dx = (Math.random() - 0.5) * width * 0.6;
      const dy = (Math.random() - 0.5) * height * 0.4;
      ctx.fillRect(dx - 2, dy - 2, 4, 4);
    }
  }

  ctx.restore();
}

function drawEnemyShip(ctx, enemy){
  const renderY = enemy.renderY || enemy.y;
  
  ctx.save();
  ctx.translate(enemy.x + enemy.width/2, renderY + enemy.height/2);
  
  ctx.fillStyle = '#0b0b0b';
  ctx.beginPath();
  ctx.moveTo(0, enemy.height * 0.50);
  ctx.quadraticCurveTo(enemy.width * 0.48, enemy.height * 0.18, enemy.width * 0.36, -enemy.height * 0.42);
  ctx.lineTo(-enemy.width * 0.36, -enemy.height * 0.42);
  ctx.quadraticCurveTo(-enemy.width * 0.48, enemy.height * 0.18, 0, enemy.height * 0.50);
  ctx.closePath();
  ctx.fill();

  ctx.save();
  ctx.globalAlpha = 0.2;
  ctx.fillStyle = '#0b0b0b';
  ctx.scale(1, -0.2);
  ctx.translate(0, -enemy.height * 1.5);
  ctx.beginPath();
  ctx.moveTo(0, enemy.height * 0.50);
  ctx.quadraticCurveTo(enemy.width * 0.48, enemy.height * 0.18, enemy.width * 0.36, -enemy.height * 0.42);
  ctx.lineTo(-enemy.width * 0.36, -enemy.height * 0.42);
  ctx.quadraticCurveTo(-enemy.width * 0.48, enemy.height * 0.18, 0, enemy.height * 0.50);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(-enemy.width * 0.16, -enemy.height * 0.18, enemy.width * 0.32, enemy.height * 0.18);
  
  ctx.fillStyle = '#0d0d0d';
  ctx.fillRect(-3, -enemy.height * 0.10, 6, enemy.height * 0.20);
  
  ctx.fillStyle = 'rgba(50,50,50,0.4)';
  ctx.fillRect(-enemy.width * 0.2, enemy.height * 0.45, enemy.width * 0.4, 2);
  
  ctx.restore();
}

function drawItem(ctx, item, bobOffset){
  ctx.save();
  ctx.translate(item.x + item.width/2, item.y + item.height/2 + bobOffset);
  
  ctx.save();
  ctx.globalAlpha = 0.3;
  ctx.scale(1, -0.4);
  ctx.translate(0, item.height);
  
  if(item.type === 'fuel'){
    ctx.fillStyle = '#ff6600';
    ctx.fillRect(-item.width/2, -item.height/2, item.width, item.height);
  } else {
    ctx.fillStyle = '#228b22';
    ctx.fillRect(-item.width/2, -item.height/2, item.width, item.height);
  }
  ctx.restore();
  
  if(item.type === 'fuel'){
    ctx.fillStyle = '#ff6600';
    ctx.fillRect(-item.width/2, -item.height/2, item.width, item.height);
    ctx.fillStyle = '#ff9900';
    ctx.fillRect(-item.width/2 + 2, -item.height/2 + 2, item.width - 4, item.height - 4);
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('F', 0, 4);
  } else {
    ctx.fillStyle = '#228b22';
    ctx.fillRect(-item.width/2, -item.height/2, item.width, item.height);
    ctx.fillStyle = '#32cd32';
    ctx.fillRect(-item.width/2 + 2, -item.height/2 + 2, item.width - 4, item.height - 4);
    ctx.fillStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-8, 0);
    ctx.lineTo(8, 0);
    ctx.moveTo(0, -8);
    ctx.lineTo(0, 8);
    ctx.stroke();
  }
  
  if(Math.sin(item.sparkleTime * 8) > 0.5){
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, 0, item.width/2 + 4, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.strokeStyle = 'rgba(173,216,230,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, item.height/2 + 5, item.width/2 + 8, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  ctx.restore();
}

function updateHUD(){
  const distance = Math.max(0, Math.floor(game.distance / 1000));
  const score = Math.max(0, Math.floor(game.score));
  
  document.getElementById('distance').textContent = distance + 'km';
  document.getElementById('score').textContent = score.toLocaleString();

  const seasonElement = document.getElementById('season');
  seasonElement.textContent = game.seasonNames[game.season];
  seasonElement.className = 'season-indicator ' + game.seasonClasses[game.season];

  const hull = Math.max(0, Math.round(player.hull));
  const fuel = Math.max(0, Math.round(player.fuel));

  document.getElementById('hullPercent').textContent = hull + '%';
  document.getElementById('fuelPercent').textContent = fuel + '%';
  document.getElementById('hullBar').style.width = hull + '%';
  document.getElementById('fuelBar').style.width = fuel + '%';
}

function endGame(){
  cleanup();
  
  beep(220, 420, 'sawtooth');
  setTimeout(() => beep(160, 420, 'sawtooth'), 200);
  setTimeout(() => beep(110, 620, 'sawtooth'), 420);
  
  const distance = Math.max(0, Math.floor(game.distance / 1000));
  const score = Math.max(0, Math.floor(game.score));
  
  document.getElementById('finalDistance').textContent = distance + ' km';
  document.getElementById('finalScore').textContent = score.toLocaleString();
  document.getElementById('finalSeason').textContent = game.seasonNames[game.season];
  document.getElementById('gameOverScreen').style.display = 'flex';
}

window.addEventListener('load', () => {
  game.canvas = document.getElementById('gameCanvas');
  if(game.canvas) {
    game.ctx = game.canvas.getContext('2d');
    resizeCanvas();
  }
  
  if(game.isMobile) {
    const controlsText = document.querySelector('.controls');
    if(controlsText) {
      controlsText.innerHTML = 'Touch left/right sides of screen to steer • Touch ☰ to pause<br><small>Keyboard controls also available</small>';
    }
  }
});
</script>
</body>
</html>
