<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
<title>Ocean's Edge - Enhanced</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: fixed;
    -webkit-overflow-scrolling: touch;
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial;
       background:#001122;overflow:hidden;height:100vh;height:100dvh;user-select:none;touch-action:none}
  #gameContainer{position:relative;width:100vw;width:100dvw;height:100vh;height:100dvh;overflow:hidden}
  #gameCanvas{display:block;width:100%;height:100%;object-fit:cover}
  .ocean-waves,.floating-waves{position:absolute;inset:0;pointer-events:none}
  .ocean-waves{
    background:
      radial-gradient(circle at 20% 80%, rgba(135,206,235,.25) 0%, transparent 50%),
      radial-gradient(circle at 80% 20%, rgba(70,130,180,.18) 0%, transparent 50%),
      radial-gradient(circle at 40% 40%, rgba(25,25,112,.08) 0%, transparent 50%);
    animation:oceanWaves 6s ease-in-out infinite; z-index:1
  }
  @keyframes oceanWaves{0%,100%{transform:translateY(0) scale(1);opacity:.65}
                        50%{transform:translateY(-15px) scale(1.02);opacity:.95}}
  .floating-waves{
    background:linear-gradient(90deg,transparent 0%, rgba(255,255,255,.08) 50%, transparent 100%);
    animation:floatingWaves 8s linear infinite; z-index:2
  }
  @keyframes floatingWaves{0%{transform:translateX(-100%)}100%{transform:translateX(100%)}}

  #hud{position:absolute;top:0;left:0;right:70px;z-index:5;
       color:#fff;padding:8px 12px;
       display:flex;flex-direction:column;align-items:flex-start;gap:8px;
       font-weight:600;font-size:14px;
       background:transparent;border:none;width:auto;max-width:400px}
  
  .hud-row{display:flex;flex-direction:row;align-items:center;gap:20px}
  .hud-stat{display:flex;align-items:center;gap:8px;
            min-width:0;flex-shrink:0}
  .hud-label{font-size:14px;opacity:.8;font-weight:500;white-space:nowrap}
  .hud-value{font-size:16px;font-weight:600;text-shadow:1px 1px 2px rgba(0,0,0,0.5);
             white-space:nowrap}
  
  .progress-mini{width:80px;height:6px;border-radius:3px;overflow:hidden;
                 background:rgba(0,0,0,.4);position:relative;
                 border:1px solid rgba(255,255,255,.3);
                 box-shadow:none;flex-shrink:0}
  .hull-fill{height:100%;background:linear-gradient(90deg,#ff4444,#44ff44);
             transition:width .4s ease;border-radius:3px;
             box-shadow:none}
  .fuel-fill{height:100%;background:linear-gradient(90deg,#ff8800,#ffdd00);
             transition:width .4s ease;border-radius:3px;
             box-shadow:none}
  .season-indicator{display:inline-block;font-weight:700;font-size:14px;
                    padding:6px 12px;border-radius:20px;
                    transition:all 0.5s ease;white-space:nowrap;flex-shrink:0;
                    margin-top:4px}
  .summer{background:linear-gradient(45deg,#ffeb3b,#ffc107);color:#333}
  .autumn{background:linear-gradient(45deg,#ff9800,#ff5722);color:#fff}
  .winter{background:linear-gradient(45deg,#2196f3,#03a9f4);color:#fff}
  .storm{background:linear-gradient(45deg,#9c27b0,#673ab7);color:#fff}

  .pause-btn{position:absolute;top:10px;right:10px;z-index:6;
             background:rgba(0,20,40,.9);color:#fff;padding:8px 12px;border-radius:8px;
             border:2px solid rgba(135,206,235,.4);cursor:pointer;
             font-size:14px;font-weight:600;transition:all .2s ease}
  .pause-btn:hover{background:rgba(70,130,180,.8);transform:translateY(-1px)}

  .performance-indicator{position:absolute;top:10px;left:10px;z-index:6;
                        background:rgba(0,20,40,.7);color:#fff;padding:4px 8px;border-radius:4px;
                        font-size:12px;font-weight:500;display:none}
  .fps-good{color:#4CAF50} .fps-ok{color:#FFC107} .fps-bad{color:#F44336}

  #menuScreen,#gameOverScreen,#pauseScreen{position:absolute;inset:0;display:flex;flex-direction:column;
      align-items:center;justify-content:center;color:#fff;text-align:center;z-index:6}
  #menuScreen{background:linear-gradient(180deg,#001122 0%,#003366 50%,#004488 100%)}
  #gameOverScreen,#pauseScreen{display:none;background:rgba(0,17,34,.95);backdrop-filter:blur(10px)}
  
  .pause-buttons{display:flex;flex-direction:row;gap:15px;margin-top:25px;
                align-items:center;justify-content:center;flex-wrap:wrap}
  
  .title{font-size:4rem;font-weight:900;color:#87CEEB;text-shadow:3px 3px 6px rgba(0,0,0,.8);margin-bottom:14px}
  .subtitle{max-width:700px;color:#B0C4DE;line-height:1.6;margin:0 20px 36px}
  .game-btn{background:linear-gradient(45deg,#9b59b6,#6bb6ff);color:#fff;border:0;padding:14px 28px;
            border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(155,89,182,.35);
            transition:transform .15s ease, box-shadow .15s ease;margin:5px}
  .game-btn:hover{transform:translateY(-2px);box-shadow:0 10px 26px rgba(155,89,182,.45)}
  .controls{margin-top:22px;color:#B0C4DE}

  .shake{animation:shake .28s ease-in-out}
  @keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}

  .combo-indicator{position:absolute;top:150px;right:20px;z-index:5;
                   background:rgba(255,215,0,.2);color:#ffd700;padding:10px 15px;border-radius:10px;
                   border:2px solid rgba(255,215,0,.5);backdrop-filter:blur(10px);
                   font-weight:bold;font-size:14px;display:none;animation:pulse 1s infinite}
  @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.05)}}

  .season-transition{position:absolute;inset:0;z-index:4;pointer-events:none;
                     background:radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
                     opacity:0;animation:seasonFlash 1s ease-out}
  @keyframes seasonFlash{0%{opacity:0}30%{opacity:1}100%{opacity:0}}

  .mobile-touch-area{position:absolute;top:0;width:50%;height:100%;z-index:3;
                     user-select:none;touch-action:none;opacity:0}
  .mobile-touch-left{left:0}
  .mobile-touch-right{right:0}

  .fallback-message{position:absolute;inset:0;display:none;flex-direction:column;
                   align-items:center;justify-content:center;background:#001122;
                   color:#fff;text-align:center;padding:20px;z-index:10}
  .fallback-message h2{color:#ff6b6b;margin-bottom:20px}

  @media (max-width: 768px) {
    .title{font-size:2.5rem}
    .subtitle{font-size:14px}
    .pause-btn{display:block !important}
    
    #hud{padding:6px 8px;right:60px}
    .hud-row{gap:15px}
    .hud-label{font-size:13px}
    .hud-value{font-size:15px}
    .season-indicator{font-size:13px;padding:5px 10px}
    
    .pause-buttons{flex-direction:column;gap:10px}
  }
  
  @media screen and (max-width: 480px) {
    .title{font-size:2rem}
    
    #hud{padding:4px 6px;right:55px}
    .hud-row{gap:12px}
    .hud-label{font-size:12px}
    .hud-value{font-size:14px}
    .season-indicator{font-size:12px;padding:4px 8px}
    .progress-mini{width:60px}
    
    .pause-buttons{flex-direction:column;gap:8px}
    .game-btn{padding:12px 24px;font-size:14px}
  }
  
  @media screen and (max-width: 360px) {
    #hud{right:50px;padding:3px 5px}
    .hud-row{gap:10px;flex-wrap:wrap}
    .hud-label{font-size:11px}
    .hud-value{font-size:13px}
    .season-indicator{font-size:10px;padding:3px 8px}
    .progress-mini{width:40px;height:4px}
  }
  
  @media screen and (max-height: 500px) and (orientation: landscape) {
    #hud{padding:2px 4px;font-size:12px}
    .hud-row{gap:12px}
    .hud-label{font-size:11px}
    .hud-value{font-size:13px}
    .season-indicator{padding:2px 6px;font-size:11px}
    
    .pause-buttons{flex-direction:row;gap:10px}
  }
</style>
</head>
<body>
<div id="gameContainer">
  <div class="ocean-waves"></div>
  <div class="floating-waves"></div>

  <div id="menuScreen">
    <h1 class="title">Ocean's Edge</h1>
    <p class="subtitle">
      Navigate treacherous waters in your sailing ship. Collect fuel and repair kits while avoiding enemy ships.
      Seasons raise the stakes — survive for the highest score.
    </p>
    <button class="game-btn" onclick="GameManager.startGame()">Set Sail</button>
    <div class="controls">Use ← → arrow keys or A D keys to steer • SPACE to pause<br><small>Touch controls available on mobile</small></div>
  </div>

  <canvas id="gameCanvas" style="display:none"></canvas>

  <div id="hud" style="display:none">
    <div class="hud-row">
      <div class="hud-stat">
        <span class="hud-label">Distance</span>
        <span class="hud-value" id="distance">0km</span>
      </div>
      
      <div class="hud-stat">
        <span class="hud-label">Health</span>
        <div class="progress-mini">
          <div id="hullBar" class="hull-fill" style="width:100%"></div>
        </div>
        <span class="hud-value" id="hullPercent">100%</span>
      </div>
    </div>
    
    <div class="hud-row">
      <div class="hud-stat">
        <span class="hud-label">Score</span>
        <span class="hud-value" id="score">0</span>
      </div>
      
      <div class="hud-stat">
        <span class="hud-label">Fuel</span>
        <div class="progress-mini">
          <div id="fuelBar" class="fuel-fill" style="width:100%"></div>
        </div>
        <span class="hud-value" id="fuelPercent">100%</span>
      </div>
    </div>
    
    <div id="season" class="season-indicator summer">Summer</div>
  </div>

  <div class="mobile-touch-area mobile-touch-left" id="mobileLeftArea" style="display:none"></div>
  <div class="mobile-touch-area mobile-touch-right" id="mobileRightArea" style="display:none"></div>

  <div class="pause-btn" id="pauseBtn" style="display:none" onclick="GameManager.togglePause()">☰</div>
  <div class="performance-indicator" id="performanceIndicator">FPS: <span id="fpsDisplay">60</span></div>

  <div class="combo-indicator" id="comboIndicator">
    <div>COMBO x<span id="comboCount">2</span></div>
    <div style="font-size:12px">+<span id="comboBonus">100</span> bonus!</div>
  </div>

  <div id="pauseScreen">
    <h2 class="title" style="font-size:3rem">Paused</h2>
    <div class="pause-buttons">
      <button class="game-btn" onclick="GameManager.togglePause()">Resume</button>
      <button class="game-btn" onclick="GameManager.restartGame()">Restart</button>
      <button class="game-btn" onclick="GameManager.returnToMenu()">Exit</button>
    </div>
  </div>

  <div id="gameOverScreen">
    <h2 class="title" style="font-size:3rem;color:#ff6b6b">Game Over</h2>
    <p style="margin:8px 0">Distance: <b id="finalDistance">0 km</b></p>
    <p style="margin:8px 0">Final Score: <b id="finalScore">0</b></p>
    <p style="margin:8px 0">Season Reached: <b id="finalSeason">Summer</b></p>
    <div style="display:flex;gap:10px;margin-top:18px">
      <button class="game-btn" onclick="GameManager.restartGame()">Play Again</button>
      <button class="game-btn" onclick="GameManager.returnToMenu()">Main Menu</button>
    </div>
  </div>

  <div class="fallback-message" id="fallbackMessage">
    <h2>Browser Not Supported</h2>
    <p>This game requires Canvas and modern JavaScript features.<br>
    Please update your browser or try a different one.</p>
  </div>
</div>

<script>
/* ============================================================================
 * CONFIGURATION MODULE - Documented Constants
 * ============================================================================ */
const CONFIG = {
  GAME: {
    TARGET_FPS: 60,
    PHYSICS_TIMESTEP: 1/60,
    MAX_DELTA_TIME: 0.05,        // Maximum allowed delta to prevent large jumps
    MIN_DELTA_TIME: 0.0001,      // Minimum delta to prevent division issues
    DEBUG_MODE: false
  },
  CANVAS: {
    MAX_DEVICE_PIXEL_RATIO: 2,   // Limit DPR to prevent performance issues
    MIN_WIDTH: 320,              // Minimum supported screen width
    MIN_HEIGHT: 480              // Minimum supported screen height
  },
  PLAYER: {
    SPEED: 7,                    // Base movement speed (pixels per frame)
    WIDTH: 36,
    HEIGHT: 56,
    HULL_DECAY_RATE: 0.6,        // Hull damage per second in normal conditions
    FUEL_CONSUMPTION_RATE: 1.0,  // Fuel consumption per second
    SAILS_WEAR_RATE: 0.3,        // Sail degradation per second
    MIN_EFFICIENCY: 0.3,         // Minimum efficiency when sails are damaged
    SIDE_MARGIN_PERCENT: 0.02,   // Screen edge buffer as percentage of width
    BOTTOM_MARGIN_PERCENT: 0.05, // Bottom screen buffer as percentage
    WAKE_TRAIL_LENGTH: 15,       // Number of wake trail segments
    BOB_AMPLITUDE: 3,            // Wave bobbing intensity (pixels)
    BOB_FREQUENCY: 2.5           // Wave bobbing speed (cycles per second)
  },
  OBSTACLES: {
    MIN_SIZE: 35,
    MAX_SIZE: 55,
    MIN_SPEED: 2,                // Minimum obstacle movement speed
    MAX_SPEED: 4,                // Maximum obstacle movement speed
    SPAWN_COOLDOWN_MS: 800,      // Minimum time between spawns (milliseconds)
    BASE_SPAWN_PROBABILITY: 0.012, // Base chance per frame to spawn
    COLLISION_DAMAGE: 22,        // Damage dealt to player on collision
    WAKE_TRAIL_LENGTH: 10
  },
  ITEMS: {
    WIDTH: 26,
    HEIGHT: 26,
    MIN_SPEED: 1.6,
    MAX_SPEED: 2.2,
    SPAWN_COOLDOWN_MS: 1200,
    BASE_SPAWN_PROBABILITY: 0.008,
    FUEL_RESTORE_AMOUNT: 30,     // Fuel restored when collected
    HULL_REPAIR_AMOUNT: 35,      // Hull repaired when collected
    SAILS_REPAIR_AMOUNT: 20      // Sails repaired when collected
  },
  SEASONS: {
    NAMES: ['Summer', 'Autumn', 'Winter', 'Storm'],
    CSS_CLASSES: ['summer', 'autumn', 'winter', 'storm'],
    SCORE_MULTIPLIERS: [1, 1.5, 2.5, 4], // Score multipliers for each season
    DISTANCE_THRESHOLDS: [0, 3000, 7000, 12000], // Distance needed to reach season
    DIFFICULTY_SCALING: 0.7,     // How much seasons affect obstacle spawn rates
    DECAY_RATE_MULTIPLIER: 0.3   // Additional decay rate per season level
  },
  COMBO: {
    DURATION_SECONDS: 3,         // How long combo lasts without collection
    SCORE_MULTIPLIER: 0.5,       // Bonus multiplier per combo level
    FUEL_BONUS_BASE: 50,         // Base bonus points for fuel collection
    REPAIR_BONUS_BASE: 75        // Base bonus points for repair collection
  },
  AUDIO: {
    MASTER_VOLUME: 0.08,
    MIN_FREQUENCY_HZ: 20,
    MAX_FREQUENCY_HZ: 20000,
    MAX_DURATION_SECONDS: 5      // Maximum allowed audio duration
  },
  PARTICLES: {
    MAX_ACTIVE_COUNT: 100,       // Maximum particles rendered simultaneously
    DEFAULT_LIFETIME: 0.6,       // Base particle lifetime (seconds)
    LIFETIME_VARIANCE: 0.4,      // Random variance in lifetime
    MIN_SIZE_PX: 1,
    MAX_SIZE_PX: 8,
    VELOCITY_RANGE: 150          // Maximum initial velocity (pixels/second)
  },
  WATER: {
    MAX_DROPLETS: 80,            // Maximum water droplets active
    DROPLET_BASE_LIFETIME: 0.8,
    DROPLET_LIFETIME_VARIANCE: 0.7,
    GRAVITY_ACCELERATION: 150,   // Downward acceleration for droplets
    SPLASH_VELOCITY_RANGE: 100   // Range of initial splash velocities
  },
  EFFECTS: {
    SCREEN_SHAKE_DURATION: 0.28, // Duration of screen shake effect
    SCREEN_SHAKE_INTENSITY: 15,  // Maximum shake displacement (pixels)
    ITEM_SPARKLE_FREQUENCY: 8,   // Sparkle animation cycles per second
    WAKE_ALPHA: 0.6,             // Opacity of wake trails
    WATER_REFLECTION_ALPHA: 0.2  // Opacity of ship reflections
  }
};

/* ============================================================================
 * BROWSER COMPATIBILITY MODULE
 * ============================================================================ */
const BrowserCompatibility = {
  isSupported: true,
  missingFeatures: [],

  checkSupport() {
    this.isSupported = true;
    this.missingFeatures = [];

    // Check Canvas support
    if (!this.checkCanvas()) {
      this.missingFeatures.push('HTML5 Canvas');
      this.isSupported = false;
    }

    // Check for essential JavaScript features
    if (!this.checkJavaScriptFeatures()) {
      this.missingFeatures.push('Modern JavaScript');
      this.isSupported = false;
    }

    // Check requestAnimationFrame
    if (!this.checkAnimationFrame()) {
      this.missingFeatures.push('requestAnimationFrame');
      this.isSupported = false;
    }

    return this.isSupported;
  },

  checkCanvas() {
    try {
      const canvas = document.createElement('canvas');
      return !!(canvas.getContext && canvas.getContext('2d'));
    } catch (e) {
      return false;
    }
  },

  checkJavaScriptFeatures() {
    try {
      // Check for Object.assign
      if (!Object.assign) return false;
      
      // Check for Math.clamp alternative (Math.max/min)
      if (!Math.max || !Math.min) return false;
      
      // Check for basic array methods
      if (!Array.prototype.forEach || !Array.prototype.splice) return false;
      
      return true;
    } catch (e) {
      return false;
    }
  },

  checkAnimationFrame() {
    return !!(window.requestAnimationFrame || 
              window.webkitRequestAnimationFrame || 
              window.mozRequestAnimationFrame || 
              window.msRequestAnimationFrame);
  },

  setupPolyfills() {
    // requestAnimationFrame polyfill
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = 
        window.webkitRequestAnimationFrame || 
        window.mozRequestAnimationFrame || 
        window.msRequestAnimationFrame || 
        function(callback) {
          return window.setTimeout(callback, 1000 / 60);
        };
    }

    // Object.assign polyfill (simplified)
    if (!Object.assign) {
      Object.assign = function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
    }
  },

  showFallbackMessage() {
    const fallback = document.getElementById('fallbackMessage');
    const menuScreen = document.getElementById('menuScreen');
    if (fallback) {
      fallback.style.display = 'flex';
    }
    if (menuScreen) {
      menuScreen.style.display = 'none';
    }
  }
};

/* ============================================================================
 * UTILITY MODULE
 * ============================================================================ */
const Utils = {
  // Safe parsing with fallback values
  safeParseInt(value, fallback) {
    if (fallback === undefined) fallback = 0;
    const parsed = parseInt(value);
    return isNaN(parsed) ? fallback : parsed;
  },

  // Safe mathematical operations with error handling
  safeMathOperation(operation, fallback) {
    if (fallback === undefined) fallback = 0;
    try {
      const result = operation();
      return isNaN(result) || !isFinite(result) ? fallback : result;
    } catch (e) {
      console.warn('Math operation failed:', e);
      return fallback;
    }
  },

  // Constrain value between min and max
  clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },

  // Linear interpolation between two values
  lerp(a, b, t) {
    return a + (b - a) * this.clamp(t, 0, 1);
  },

  // Random float in range
  randomRange(min, max) {
    return min + Math.random() * (max - min);
  },

  // Random integer in range (inclusive)
  randomInt(min, max) {
    return Math.floor(this.randomRange(min, max + 1));
  },

  // Axis-aligned bounding box collision detection
  aabb(a, b) {
    if (!a || !b) return false;
    return a.x < b.x + b.width &&
           a.x + a.width > b.x &&
           a.y < b.y + b.height &&
           a.y + a.height > b.y;
  },

  // Mobile device detection
  isMobile() {
    return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  }
};

/* ============================================================================
 * OBJECT POOL - Performance optimization for frequently created objects
 * ============================================================================ */
const ObjectPool = {
  particles: [],
  waterDroplets: [],
  wakeTrailNodes: [],

  getParticle() {
    return this.particles.pop() || {
      x: 0, y: 0, vx: 0, vy: 0, color: '#ffffff',
      life: 0, maxLife: 0, alpha: 1, size: 2
    };
  },

  releaseParticle(particle) {
    if (this.particles.length < CONFIG.PARTICLES.MAX_ACTIVE_COUNT) {
      this.particles.push(particle);
    }
  },

  getWaterDroplet() {
    return this.waterDroplets.pop() || {
      x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, alpha: 1, size: 2
    };
  },

  releaseWaterDroplet(droplet) {
    if (this.waterDroplets.length < CONFIG.WATER.MAX_DROPLETS) {
      this.waterDroplets.push(droplet);
    }
  },

  getWakeNode() {
    return this.wakeTrailNodes.pop() || { x: 0, y: 0, age: 0 };
  },

  releaseWakeNode(node) {
    if (this.wakeTrailNodes.length < 200) {
      this.wakeTrailNodes.push(node);
    }
  }
};

/* ============================================================================
 * PERFORMANCE MONITOR MODULE
 * ============================================================================ */
const PerformanceMonitor = {
  frameCount: 0,
  lastFpsUpdate: 0,
  currentFps: 60,
  frameTimeHistory: [],
  qualityLevel: 'high', // high, medium, low

  init() {
    if (CONFIG.GAME.DEBUG_MODE) {
      const indicator = document.getElementById('performanceIndicator');
      if (indicator) indicator.style.display = 'block';
    }
  },

  update(deltaTime) {
    this.frameCount++;
    this.frameTimeHistory.push(deltaTime);
    
    // Keep only last 60 frames for averaging
    if (this.frameTimeHistory.length > 60) {
      this.frameTimeHistory.shift();
    }

    const now = performance.now();
    if (now - this.lastFpsUpdate >= 1000) {
      this.currentFps = Math.round(1000 / (now - this.lastFpsUpdate) * this.frameCount);
      this.frameCount = 0;
      this.lastFpsUpdate = now;
      
      this.updateQualityLevel();
      this.updateDisplay();
    }
  },

  updateQualityLevel() {
    const LOW_FPS_THRESHOLD = 30;
    const MEDIUM_FPS_THRESHOLD = 45;
    
    if (this.currentFps < LOW_FPS_THRESHOLD) {
      this.qualityLevel = 'low';
    } else if (this.currentFps < MEDIUM_FPS_THRESHOLD) {
      this.qualityLevel = 'medium';
    } else {
      this.qualityLevel = 'high';
    }
  },

  updateDisplay() {
    if (!CONFIG.GAME.DEBUG_MODE) return;
    
    const fpsDisplay = document.getElementById('fpsDisplay');
    if (fpsDisplay) {
      fpsDisplay.textContent = this.currentFps;
      const fpsClass = this.currentFps >= 45 ? 'fps-good' : 
                       this.currentFps >= 30 ? 'fps-ok' : 'fps-bad';
      fpsDisplay.className = fpsClass;
    }
  },

  // Quality-based limits for performance optimization
  getParticleLimit() {
    const QUALITY_MULTIPLIERS = { low: 0.3, medium: 0.6, high: 1.0 };
    return Math.floor(CONFIG.PARTICLES.MAX_ACTIVE_COUNT * QUALITY_MULTIPLIERS[this.qualityLevel]);
  },

  getWaterDropletLimit() {
    const QUALITY_MULTIPLIERS = { low: 0.4, medium: 0.7, high: 1.0 };
    return Math.floor(CONFIG.WATER.MAX_DROPLETS * QUALITY_MULTIPLIERS[this.qualityLevel]);
  }
};

/* ============================================================================
 * AUDIO MANAGER MODULE - With fallback for unsupported browsers
 * ============================================================================ */
const AudioManager = {
  context: null,
  initialized: false,
  supported: true,

  init() {
    if (this.initialized || this.context) return;
    
    try {
      // Check if Web Audio API is supported
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!AudioContext) {
        this.supported = false;
        console.warn('Web Audio API not supported');
        return;
      }

      this.context = new AudioContext();

      if (this.context.state === 'suspended') {
        const resumeAudio = () => {
          if (this.context && this.context.state === 'suspended') {
            this.context.resume().then(() => {
              this.initialized = true;
            }).catch(e => {
              console.warn('Audio resume failed:', e);
              this.context = null;
              this.supported = false;
            });
          }
          document.removeEventListener('touchstart', resumeAudio, { passive: true });
          document.removeEventListener('click', resumeAudio);
        };

        document.addEventListener('touchstart', resumeAudio, { passive: true });
        document.addEventListener('click', resumeAudio);
      } else {
        this.initialized = true;
      }
    } catch (e) {
      console.warn('Audio not available:', e);
      this.context = null;
      this.supported = false;
    }
  },

  playTone(frequency, duration, type, volume) {
    if (!this.supported || !this.context || !this.initialized) return;
    
    // Set defaults
    frequency = frequency || 440;
    duration = duration || 120;
    type = type || 'sine';
    volume = volume || 1;
    
    try {
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();

      oscillator.type = type;
      oscillator.frequency.value = Utils.clamp(frequency, CONFIG.AUDIO.MIN_FREQUENCY_HZ, CONFIG.AUDIO.MAX_FREQUENCY_HZ);
      oscillator.connect(gainNode);
      gainNode.connect(this.context.destination);

      const vol = Utils.clamp(CONFIG.AUDIO.MASTER_VOLUME * volume, 0, 1);
      const currentTime = this.context.currentTime;
      const endTime = currentTime + Utils.clamp(duration / 1000, 0.01, CONFIG.AUDIO.MAX_DURATION_SECONDS);
      
      gainNode.gain.setValueAtTime(vol, currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, endTime);

      oscillator.start(currentTime);
      oscillator.stop(endTime);
    } catch (e) {
      console.warn('Audio playback error:', e);
    }
  },

  cleanup() {
    if (this.context && this.context.state !== 'closed') {
      try {
        this.context.close();
        this.context = null;
        this.initialized = false;
      } catch (e) {
        console.warn('Audio cleanup failed:', e);
      }
    }
  }
};

/* ============================================================================
 * PARTICLE SYSTEM MODULE - Optimized with object pooling
 * ============================================================================ */
const ParticleSystem = {
  activeParticles: [],
  activeWaterDroplets: [],

  update(deltaTime) {
    this.updateParticles(deltaTime);
    this.updateWaterDroplets(deltaTime);
  },

  updateParticles(deltaTime) {
    const limit = PerformanceMonitor.getParticleLimit();
    
    for (let i = this.activeParticles.length - 1; i >= 0; i--) {
      const particle = this.activeParticles[i];
      if (!particle) {
        this.activeParticles.splice(i, 1);
        continue;
      }

      this.updateParticlePosition(particle, deltaTime);
      this.updateParticleLife(particle, deltaTime);

      if (particle.life <= 0) {
        ObjectPool.releaseParticle(this.activeParticles.splice(i, 1)[0]);
      }
    }

    // Enforce performance limits
    if (this.activeParticles.length > limit) {
      const excess = this.activeParticles.splice(0, this.activeParticles.length - limit);
      excess.forEach(particle => ObjectPool.releaseParticle(particle));
    }
  },

  updateParticlePosition(particle, deltaTime) {
    particle.x += (particle.vx || 0) * deltaTime;
    particle.y += (particle.vy || 0) * deltaTime;
  },

  updateParticleLife(particle, deltaTime) {
    particle.life = (particle.life || 0) - deltaTime;
    particle.alpha = Utils.clamp(particle.life / (particle.maxLife || 1), 0, 1);
  },

  updateWaterDroplets(deltaTime) {
    const limit = PerformanceMonitor.getWaterDropletLimit();
    
    for (let i = this.activeWaterDroplets.length - 1; i >= 0; i--) {
      const drop = this.activeWaterDroplets[i];
      if (!drop) {
        this.activeWaterDroplets.splice(i, 1);
        continue;
      }

      this.updateDropletPhysics(drop, deltaTime);
      this.updateParticleLife(drop, deltaTime);

      if (drop.life <= 0 || drop.y > GameState.height + 50) {
        ObjectPool.releaseWaterDroplet(this.activeWaterDroplets.splice(i, 1)[0]);
      }
    }

    if (this.activeWaterDroplets.length > limit) {
      const excess = this.activeWaterDroplets.splice(0, this.activeWaterDroplets.length - limit);
      excess.forEach(droplet => ObjectPool.releaseWaterDroplet(droplet));
    }
  },

  updateDropletPhysics(droplet, deltaTime) {
    droplet.x += (droplet.vx || 0) * deltaTime;
    droplet.y += (droplet.vy || 0) * deltaTime;
    droplet.vy = (droplet.vy || 0) + CONFIG.WATER.GRAVITY_ACCELERATION * deltaTime;
  },

  createParticles(x, y, color, count) {
    const safeCount = Utils.clamp(count || 8, 0, 50);
    const limit = PerformanceMonitor.getParticleLimit();
    
    for (let i = 0; i < safeCount; i++) {
      if (this.activeParticles.length >= limit) break;
      
      const particle = ObjectPool.getParticle();
      this.initializeParticle(particle, x, y, color);
      this.activeParticles.push(particle);
    }
  },

  initializeParticle(particle, x, y, color) {
    const SPREAD_RADIUS = 20;
    const HALF_VELOCITY_RANGE = CONFIG.PARTICLES.VELOCITY_RANGE / 2;
    
    particle.x = x + (Math.random() - 0.5) * SPREAD_RADIUS;
    particle.y = y + (Math.random() - 0.5) * SPREAD_RADIUS;
    particle.vx = (Math.random() - 0.5) * CONFIG.PARTICLES.VELOCITY_RANGE;
    particle.vy = (Math.random() - 0.5) * CONFIG.PARTICLES.VELOCITY_RANGE;
    particle.color = color || '#ffffff';
    particle.life = CONFIG.PARTICLES.DEFAULT_LIFETIME + Math.random() * CONFIG.PARTICLES.LIFETIME_VARIANCE;
    particle.maxLife = particle.life;
    particle.alpha = 1;
    particle.size = Utils.clamp(2 + Math.random() * 4, CONFIG.PARTICLES.MIN_SIZE_PX, CONFIG.PARTICLES.MAX_SIZE_PX);
  },

  createWaterDroplets(x, y, count) {
    const safeCount = Utils.clamp(count || 5, 0, 20);
    const limit = PerformanceMonitor.getWaterDropletLimit();
    
    for (let i = 0; i < safeCount; i++) {
      if (this.activeWaterDroplets.length >= limit) break;
      
      const droplet = ObjectPool.getWaterDroplet();
      this.initializeWaterDroplet(droplet, x, y);
      this.activeWaterDroplets.push(droplet);
    }
  },

  initializeWaterDroplet(droplet, x, y) {
    const SPLASH_SPREAD = 30;
    const UPWARD_VELOCITY_BASE = -50;
    const UPWARD_VELOCITY_RANGE = CONFIG.WATER.SPLASH_VELOCITY_RANGE;
    
    droplet.x = x + (Math.random() - 0.5) * SPLASH_SPREAD;
    droplet.y = y + (Math.random() - 0.5) * 20;
    droplet.vx = (Math.random() - 0.5) * CONFIG.WATER.SPLASH_VELOCITY_RANGE;
    droplet.vy = UPWARD_VELOCITY_BASE - Math.random() * UPWARD_VELOCITY_RANGE;
    droplet.life = CONFIG.WATER.DROPLET_BASE_LIFETIME + Math.random() * CONFIG.WATER.DROPLET_LIFETIME_VARIANCE;
    droplet.maxLife = droplet.life;
    droplet.alpha = 1;
    droplet.size = Utils.clamp(2 + Math.random() * 4, 1, 8);
  },

  clear() {
    // Return all active particles to pools
    this.activeParticles.forEach(particle => ObjectPool.releaseParticle(particle));
    this.activeWaterDroplets.forEach(droplet => ObjectPool.releaseWaterDroplet(droplet));
    
    this.activeParticles.length = 0;
    this.activeWaterDroplets.length = 0;
  }
};

/* ============================================================================
 * GAME STATE MODULE - Cached DOM elements for performance
 * ============================================================================ */
const GameState = {
  canvas: null,
  ctx: null,
  width: 0,
  height: 0,
  running: false,
  paused: false,
  lastTime: 0,
  distance: 0,
  score: 0,
  season: 0,
  shakeTime: 0,
  combo: 0,
  comboTimer: 0,
  isMobile: Utils.isMobile(),
  lastObstacleSpawn: 0,
  lastItemSpawn: 0,
  oceanTime: 0,
  devicePixelRatio: Math.min(window.devicePixelRatio || 1, CONFIG.CANVAS.MAX_DEVICE_PIXEL_RATIO),
  initialPlayerY: 0,

  // Cached DOM elements for performance
  cachedElements: {},

  cacheElement(id) {
    if (!this.cachedElements[id]) {
      this.cachedElements[id] = document.getElementById(id);
    }
    return this.cachedElements[id];
  },

  reset() {
    Object.assign(this, {
      distance: 0, score: 0, season: 0, shakeTime: 0,
      combo: 0, comboTimer: 0, paused: false,
      lastObstacleSpawn: 0, lastItemSpawn: 0, oceanTime: 0
    });
  }
};

/* ============================================================================
 * PLAYER MODULE - Decomposed into smaller functions
 * ============================================================================ */
const Player = {
  x: 0, y: 0,
  width: CONFIG.PLAYER.WIDTH,
  height: CONFIG.PLAYER.HEIGHT,
  speed: CONFIG.PLAYER.SPEED,
  hull: 100, fuel: 100, sails: 100,
  hullDecay: CONFIG.PLAYER.HULL_DECAY_RATE,
  fuelDecay: CONFIG.PLAYER.FUEL_CONSUMPTION_RATE,
  sailsDecay: CONFIG.PLAYER.SAILS_WEAR_RATE,
  bobOffset: 0,
  wakeTrail: [],

  reset() {
    Object.assign(this, {
      hull: 100, fuel: 100, sails: 100,
      bobOffset: 0
    });
    
    // Clear wake trail and return nodes to pool
    this.wakeTrail.forEach(node => ObjectPool.releaseWakeNode(node));
    this.wakeTrail.length = 0;
  },

  update(deltaTime, keys, touchState) {
    this.updateMovement(deltaTime, keys, touchState);
    this.updateBoundaries();
    this.updateResources(deltaTime);
    this.updateEffects(deltaTime);
  },

  updateMovement(deltaTime, keys, touchState) {
    const sailEfficiency = Utils.clamp(this.sails / 100, CONFIG.PLAYER.MIN_EFFICIENCY, 1);
    const moveSpeed = Utils.safeMathOperation(() => 
      this.speed * (0.5 + sailEfficiency * 0.5), this.speed
    );

    const SPLASH_PROBABILITY = 0.3;

    if (keys['ArrowLeft'] || keys['KeyA'] || touchState.left) {
      this.x -= moveSpeed;
      if (Math.random() < SPLASH_PROBABILITY) {
        ParticleSystem.createWaterDroplets(this.x, this.y + this.height / 2, 2);
      }
    }
    if (keys['ArrowRight'] || keys['KeyD'] || touchState.right) {
      this.x += moveSpeed;
      if (Math.random() < SPLASH_PROBABILITY) {
        ParticleSystem.createWaterDroplets(this.x + this.width, this.y + this.height / 2, 2);
      }
    }
  },

  updateBoundaries() {
    const sideMargin = Math.max(5, GameState.width * CONFIG.PLAYER.SIDE_MARGIN_PERCENT);
    this.x = Utils.clamp(this.x, sideMargin, GameState.width - this.width - sideMargin);

    const bottomMargin = Math.max(30, GameState.height * CONFIG.PLAYER.BOTTOM_MARGIN_PERCENT);
    const maxY = GameState.height - this.height - bottomMargin;
    const VERTICAL_THRESHOLD = 0.7;
    
    if (this.y < maxY * VERTICAL_THRESHOLD) {
      this.y = maxY;
    }
  },

  updateResources(deltaTime) {
    const decayMultiplier = 1 + GameState.season * CONFIG.SEASONS.DECAY_RATE_MULTIPLIER;
    
    this.hull = Utils.clamp(this.hull - this.hullDecay * deltaTime * decayMultiplier, 0, 100);
    this.fuel = Utils.clamp(this.fuel - this.fuelDecay * deltaTime * decayMultiplier, 0, 100);
    this.sails = Utils.clamp(this.sails - this.sailsDecay * deltaTime * decayMultiplier, 0, 100);
  },

  updateEffects(deltaTime) {
    this.updateWakeTrail(deltaTime);
    this.updateBobbing();
  },

  updateWakeTrail(deltaTime) {
    if (this.wakeTrail.length > CONFIG.PLAYER.WAKE_TRAIL_LENGTH) {
      ObjectPool.releaseWakeNode(this.wakeTrail.shift());
    }
    
    const wakeNode = ObjectPool.getWakeNode();
    wakeNode.x = this.x + this.width / 2;
    wakeNode.y = this.y + this.height;
    wakeNode.age = 0;
    this.wakeTrail.push(wakeNode);

    this.wakeTrail.forEach(wake => {
      if (wake) wake.age += deltaTime;
    });
  },

  updateBobbing() {
    this.bobOffset = Utils.safeMathOperation(() => 
      Math.sin(GameState.oceanTime * CONFIG.PLAYER.BOB_FREQUENCY) * CONFIG.PLAYER.BOB_AMPLITUDE + 
      Math.sin(GameState.oceanTime * 1.8) * 1.5, 0
    );
  },

  setInitialPosition() {
    const bottomMargin = Math.max(30, GameState.height * CONFIG.PLAYER.BOTTOM_MARGIN_PERCENT);
    const sideMargin = Math.max(10, GameState.width * CONFIG.PLAYER.SIDE_MARGIN_PERCENT);

    this.x = Utils.clamp((GameState.width - this.width) / 2, sideMargin, GameState.width - this.width - sideMargin);
    this.y = Utils.clamp(GameState.height - this.height - bottomMargin, 0, GameState.height - this.height);

    GameState.initialPlayerY = this.y;
  },

  repositionOnResize() {
    const bottomMargin = Math.max(30, GameState.height * CONFIG.PLAYER.BOTTOM_MARGIN_PERCENT);
    const sideMargin = Math.max(10, GameState.width * CONFIG.PLAYER.SIDE_MARGIN_PERCENT);

    const centerX = (GameState.width - this.width) / 2;
    if (centerX >= sideMargin && centerX <= GameState.width - this.width - sideMargin) {
      this.x = centerX;
    } else {
      this.x = Utils.clamp(this.x, sideMargin, GameState.width - this.width - sideMargin);
    }

    const newY = GameState.height - this.height - bottomMargin;
    this.y = Utils.clamp(newY, 0, GameState.height - this.height);

    this.x = Utils.clamp(this.x, 0, GameState.width - this.width);
    this.y = Utils.clamp(this.y, 0, GameState.height - this.height);
  }
};

/* ============================================================================
 * GAME OBJECTS MODULE - Split into smaller functions
 * ============================================================================ */
const GameObjects = {
  obstacles: [],
  items: [],

  update(deltaTime) {
    this.updateObstacles(deltaTime);
    this.updateItems(deltaTime);
    this.spawnObjects();
  },

  updateObstacles(deltaTime) {
    for (let i = this.obstacles.length - 1; i >= 0; i--) {
      const obstacle = this.obstacles[i];
      if (!obstacle) {
        this.obstacles.splice(i, 1);
        continue;
      }

      this.updateObstacleMovement(obstacle, deltaTime);
      this.updateObstacleWake(obstacle, deltaTime);

      if (this.isObstacleOffScreen(obstacle)) {
        this.cleanupObstacle(i);
      }
    }
  },

  updateObstacleMovement(obstacle, deltaTime) {
    obstacle.y += obstacle.speed;
    obstacle.rotation += (obstacle.rotationSpeed || 0) * deltaTime;
  },

  updateObstacleWake(obstacle, deltaTime) {
    if (!obstacle.wakeTrail) obstacle.wakeTrail = [];
    
    if (obstacle.wakeTrail.length > CONFIG.OBSTACLES.WAKE_TRAIL_LENGTH) {
      ObjectPool.releaseWakeNode(obstacle.wakeTrail.shift());
    }
    
    const wakeNode = ObjectPool.getWakeNode();
    wakeNode.x = obstacle.x + obstacle.width / 2;
    wakeNode.y = obstacle.y + obstacle.height;
    wakeNode.age = 0;
    obstacle.wakeTrail.push(wakeNode);
    
    obstacle.wakeTrail.forEach(wake => {
      if (wake) wake.age += deltaTime;
    });
  },

  isObstacleOffScreen(obstacle) {
    const OFF_SCREEN_BUFFER = 100;
    return obstacle.y > GameState.height + OFF_SCREEN_BUFFER;
  },

  cleanupObstacle(index) {
    const obstacle = this.obstacles[index];
    if (obstacle && obstacle.wakeTrail) {
      obstacle.wakeTrail.forEach(node => ObjectPool.releaseWakeNode(node));
    }
    this.obstacles.splice(index, 1);
  },

  updateItems(deltaTime) {
    for (let i = this.items.length - 1; i >= 0; i--) {
      const item = this.items[i];
      if (!item) {
        this.items.splice(i, 1);
        continue;
      }

      item.y += item.speed;
      item.sparkleTime += deltaTime;

      if (this.isItemOffScreen(item)) {
        this.items.splice(i, 1);
      }
    }
  },

  isItemOffScreen(item) {
    const OFF_SCREEN_BUFFER = 50;
    return item.y > GameState.height + OFF_SCREEN_BUFFER;
  },

  spawnObjects() {
    this.attemptObstacleSpawn();
    this.attemptItemSpawn();
  },

  attemptObstacleSpawn() {
    const seasonMultiplier = 1 + GameState.season * CONFIG.SEASONS.DIFFICULTY_SCALING;
    const currentTime = performance.now();

    const timeSinceLastSpawn = currentTime - GameState.lastObstacleSpawn;
    if (timeSinceLastSpawn > (CONFIG.OBSTACLES.SPAWN_COOLDOWN_MS / seasonMultiplier)) {
      const spawnProbability = CONFIG.OBSTACLES.BASE_SPAWN_PROBABILITY * seasonMultiplier;
      
      if (Math.random() < spawnProbability) {
        this.spawnObstacle();
        GameState.lastObstacleSpawn = currentTime;
      }
    }
  },

  attemptItemSpawn() {
    const currentTime = performance.now();
    const timeSinceLastSpawn = currentTime - GameState.lastItemSpawn;
    
    if (timeSinceLastSpawn > CONFIG.ITEMS.SPAWN_COOLDOWN_MS) {
      if (Math.random() < CONFIG.ITEMS.BASE_SPAWN_PROBABILITY) {
        this.spawnItem();
        GameState.lastItemSpawn = currentTime;
      }
    }
  },

  spawnObstacle() {
    const size = Utils.clamp(
      CONFIG.OBSTACLES.MIN_SIZE + Math.random() * 20, 
      CONFIG.OBSTACLES.MIN_SIZE, 
      CONFIG.OBSTACLES.MAX_SIZE
    );

    const obstacle = {
      x: Utils.clamp(Math.random() * (GameState.width - size), 0, GameState.width - size),
      y: -60,
      width: size,
      height: size * 1.2,
      speed: this.calculateObstacleSpeed(),
      type: 'enemyShip',
      rotation: 0,
      rotationSpeed: 0,
      wakeTrail: []
    };

    this.obstacles.push(obstacle);
  },

  calculateObstacleSpeed() {
    const seasonSpeedBonus = GameState.season * 1.1;
    const randomVariation = Math.random() * 1.8;
    return Utils.clamp(
      CONFIG.OBSTACLES.MIN_SPEED + seasonSpeedBonus + randomVariation,
      CONFIG.OBSTACLES.MIN_SPEED,
      CONFIG.OBSTACLES.MAX_SPEED + GameState.season
    );
  },

  spawnItem() {
    const item = {
      x: Utils.clamp(
        Math.random() * (GameState.width - CONFIG.ITEMS.WIDTH), 
        0, 
        GameState.width - CONFIG.ITEMS.WIDTH
      ),
      y: -CONFIG.ITEMS.HEIGHT,
      width: CONFIG.ITEMS.WIDTH,
      height: CONFIG.ITEMS.HEIGHT,
      speed: Utils.clamp(
        CONFIG.ITEMS.MIN_SPEED + GameState.season * 0.6, 
        CONFIG.ITEMS.MIN_SPEED, 
        CONFIG.ITEMS.MAX_SPEED
      ),
      type: Math.random() < 0.5 ? 'fuel' : 'repair',
      bobOffset: Math.random() * Math.PI * 2,
      sparkleTime: 0
    };

    this.items.push(item);
  },

  clear() {
    // Clean up wake trails before clearing arrays
    this.obstacles.forEach(obstacle => {
      if (obstacle && obstacle.wakeTrail) {
        obstacle.wakeTrail.forEach(node => ObjectPool.releaseWakeNode(node));
      }
    });
    
    this.obstacles.length = 0;
    this.items.length = 0;
  }
};

/* ============================================================================
 * COLLISION SYSTEM MODULE
 * ============================================================================ */
const CollisionSystem = {
  checkCollisions() {
    this.checkObstacleCollisions();
    this.checkItemCollisions();
  },

  checkObstacleCollisions() {
    for (let i = GameObjects.obstacles.length - 1; i >= 0; i--) {
      const obstacle = GameObjects.obstacles[i];
      if (obstacle && Utils.aabb(Player, obstacle)) {
        GameObjects.obstacles.splice(i, 1);
        this.handleObstacleHit(obstacle);
      }
    }
  },

  checkItemCollisions() {
    for (let i = GameObjects.items.length - 1; i >= 0; i--) {
      const item = GameObjects.items[i];
      if (item && Utils.aabb(Player, item)) {
        GameObjects.items.splice(i, 1);
        this.handleItemCollection(item);
      }
    }
  },

  handleObstacleHit(obstacle) {
    this.resetCombo();
    this.damagePlayer();
    this.playCollisionEffects(obstacle);
    this.triggerScreenShake();
  },

  resetCombo() {
    GameState.combo = 0;
    const indicator = GameState.cacheElement('comboIndicator');
    if (indicator) indicator.style.display = 'none';
  },

  damagePlayer() {
    Player.hull = Math.max(0, Player.hull - CONFIG.OBSTACLES.COLLISION_DAMAGE);
  },

  playCollisionEffects(obstacle) {
    const COLLISION_SOUND_FREQ = 160;
    const COLLISION_SOUND_DURATION = 280;
    
    AudioManager.playTone(COLLISION_SOUND_FREQ, COLLISION_SOUND_DURATION, 'sawtooth');
    
    const centerX = obstacle.x + obstacle.width / 2;
    const centerY = obstacle.y + obstacle.height / 2;
    
    ParticleSystem.createParticles(centerX, centerY, '#ff4444', 12);
    ParticleSystem.createWaterDroplets(centerX, centerY, 15);
  },

  handleItemCollection(item) {
    this.updateCombo();
    this.applyItemEffects(item);
    this.playCollectionEffects(item);
  },

  updateCombo() {
    GameState.combo = Math.max(1, GameState.combo + 1);
    GameState.comboTimer = CONFIG.COMBO.DURATION_SECONDS;
    
    this.updateComboDisplay();
  },

  updateComboDisplay() {
    if (GameState.combo > 1) {
      const countElement = GameState.cacheElement('comboCount');
      const bonusElement = GameState.cacheElement('comboBonus');
      const indicator = GameState.cacheElement('comboIndicator');
      
      const baseBonus = CONFIG.COMBO.FUEL_BONUS_BASE;
      const comboBonus = Utils.safeMathOperation(() => baseBonus * (GameState.combo - 1), 0);
      GameState.score = Math.max(0, GameState.score + comboBonus);
      
      if (countElement) countElement.textContent = GameState.combo;
      if (bonusElement) bonusElement.textContent = comboBonus;
      if (indicator) indicator.style.display = 'block';
    }
  },

  applyItemEffects(item) {
    if (item.type === 'fuel') {
      Player.fuel = Math.min(100, Player.fuel + CONFIG.ITEMS.FUEL_RESTORE_AMOUNT);
    } else {
      Player.hull = Math.min(100, Player.hull + CONFIG.ITEMS.HULL_REPAIR_AMOUNT);
      Player.sails = Math.min(100, Player.sails + CONFIG.ITEMS.SAILS_REPAIR_AMOUNT);
    }
  },

  playCollectionEffects(item) {
    const COLLECTION_SOUND_FREQ_BASE = 420;
    const COLLECTION_SOUND_DURATION = 140;
    
    const soundFreq = item.type === 'fuel' ? COLLECTION_SOUND_FREQ_BASE : COLLECTION_SOUND_FREQ_BASE + 100;
    AudioManager.playTone(soundFreq, COLLECTION_SOUND_DURATION, 'sine');
    
    const centerX = item.x + item.width / 2;
    const centerY = item.y + item.height / 2;
    const particleColor = item.type === 'fuel' ? '#ff9900' : '#32cd32';
    
    ParticleSystem.createParticles(centerX, centerY, particleColor, 10);
    ParticleSystem.createWaterDroplets(centerX, centerY, 3);
  },

  triggerScreenShake() {
    GameState.shakeTime = CONFIG.EFFECTS.SCREEN_SHAKE_DURATION;
    const gameContainer = document.getElementById('gameContainer');
    if (gameContainer) {
      gameContainer.classList.add('shake');
      setTimeout(() => {
        gameContainer.classList.remove('shake');
      }, CONFIG.EFFECTS.SCREEN_SHAKE_DURATION * 1000);
    }
  }
};

/* ============================================================================
 * SEASON SYSTEM MODULE
 * ============================================================================ */
const SeasonSystem = {
  update() {
    const newSeason = this.calculateCurrentSeason();

    if (this.isSeasonChange(newSeason)) {
      GameState.season = newSeason;
      this.handleSeasonTransition();
    }
  },

  calculateCurrentSeason() {
    return CONFIG.SEASONS.DISTANCE_THRESHOLDS.findIndex((threshold, i) =>
      i === CONFIG.SEASONS.DISTANCE_THRESHOLDS.length - 1 || 
      GameState.distance < CONFIG.SEASONS.DISTANCE_THRESHOLDS[i + 1]
    );
  },

  isSeasonChange(newSeason) {
    return newSeason !== GameState.season && 
           newSeason >= 0 && 
           newSeason < CONFIG.SEASONS.NAMES.length;
  },

  handleSeasonTransition() {
    this.playSeasonChangeSound();
    this.createSeasonParticles();
    this.showSeasonTransition();
  },

  playSeasonChangeSound() {
    const BASE_FREQUENCY = 220;
    const FREQUENCY_INCREMENT = 120;
    const SOUND_DURATION = 200;
    
    const frequency = BASE_FREQUENCY + GameState.season * FREQUENCY_INCREMENT;
    AudioManager.playTone(frequency, SOUND_DURATION, 'triangle');
  },

  createSeasonParticles() {
    const SEASON_PARTICLE_COUNT = 15;
    const centerX = Player.x + Player.width / 2;
    const centerY = Player.y;
    
    ParticleSystem.createParticles(centerX, centerY, '#ffffaa', SEASON_PARTICLE_COUNT);
  },

  showSeasonTransition() {
    const gameContainer = document.getElementById('gameContainer');
    if (!gameContainer) return;
    
    const transition = document.createElement('div');
    transition.className = 'season-transition';
    gameContainer.appendChild(transition);
    
    const TRANSITION_DURATION = 1000;
    setTimeout(() => {
      if (transition.parentNode) {
        transition.parentNode.removeChild(transition);
      }
    }, TRANSITION_DURATION);
  }
};

/* ============================================================================
 * RENDERER MODULE - Split into smaller, focused functions
 * ============================================================================ */
const Renderer = {
  render() {
    const ctx = GameState.ctx;
    if (!ctx) return;

    ctx.save();
    this.applyScreenShake(ctx);
    this.renderScene(ctx);
    ctx.restore();
  },

  applyScreenShake(ctx) {
    if (GameState.shakeTime <= 0) return;
    
    const intensity = GameState.shakeTime * CONFIG.EFFECTS.SCREEN_SHAKE_INTENSITY;
    const shakeX = (Math.random() - 0.5) * intensity;
    const shakeY = (Math.random() - 0.5) * intensity;
    ctx.translate(shakeX, shakeY);
  },

  renderScene(ctx) {
    this.renderOcean(ctx);
    this.renderPlayer(ctx);
    this.renderObstacles(ctx);
    this.renderItems(ctx);
    this.renderOceanEffects(ctx);
    this.renderParticles(ctx);
  },

  renderOcean(ctx) {
    this.createOceanGradient(ctx);
    
    if (PerformanceMonitor.qualityLevel !== 'low') {
      this.renderOceanFloor(ctx);
    }
  },

  createOceanGradient(ctx) {
    const gradient = ctx.createLinearGradient(0, 0, 0, GameState.height);
    const colors = this.getCurrentSeasonColors();

    gradient.addColorStop(0, colors.surface);
    gradient.addColorStop(0.3, colors.shallow);
    gradient.addColorStop(0.7, colors.deep);
    gradient.addColorStop(1, colors.deep);

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, GameState.width, GameState.height);
  },

  getCurrentSeasonColors() {
    const WATER_COLOR_SETS = [
      { surface: '#87CEEB', shallow: '#4682B4', deep: '#191970', accent: '#20B2AA' },
      { surface: '#6B8DB5', shallow: '#2F4F4F', deep: '#1C3A3A', accent: '#4682B4' },
      { surface: '#B0C4DE', shallow: '#4682B4', deep: '#0F1B44', accent: '#87CEFA' },
      { surface: '#2F2F2F', shallow: '#1C1C1C', deep: '#000000', accent: '#4B0082' }
    ];
    
    return WATER_COLOR_SETS[Utils.clamp(GameState.season, 0, WATER_COLOR_SETS.length - 1)];
  },

  renderOceanFloor(ctx) {
    const FLOOR_Y_RATIO = 0.85;
    const floorY = GameState.height * FLOOR_Y_RATIO;
    const floorHeight = GameState.height - floorY;

    ctx.save();
    ctx.globalAlpha = 0.1;

    this.drawOceanFloorGradient(ctx, floorY, floorHeight);
    
    if (PerformanceMonitor.qualityLevel === 'high') {
      this.drawSeaweed(ctx, floorY);
    }
    
    ctx.restore();
  },

  drawOceanFloorGradient(ctx, floorY, floorHeight) {
    const floorGradient = ctx.createLinearGradient(0, floorY, 0, GameState.height);
    floorGradient.addColorStop(0, 'transparent');
    floorGradient.addColorStop(0.3, 'rgba(139,126,102,0.3)');
    floorGradient.addColorStop(1, 'rgba(101,67,33,0.5)');

    ctx.fillStyle = floorGradient;
    ctx.fillRect(0, floorY, GameState.width, floorHeight);
  },

  drawSeaweed(ctx, floorY) {
    const SEAWEED_COUNT = 12;
    const SEAWEED_BASE_HEIGHT = 30;
    const SEAWEED_HEIGHT_VARIANCE = 15;
    
    ctx.strokeStyle = 'rgba(34,139,34,0.4)';
    ctx.lineWidth = 2;

    for (let i = 0; i < SEAWEED_COUNT; i++) {
      this.drawSingleSeaweed(ctx, i, floorY, SEAWEED_BASE_HEIGHT, SEAWEED_HEIGHT_VARIANCE);
    }
  },

  drawSingleSeaweed(ctx, index, floorY, baseHeight, heightVariance) {
    const time = GameState.oceanTime;
    const x = (GameState.width / 12) * index + Math.sin(time + index) * 20;
    const height = baseHeight + Math.sin(time * 0.7 + index) * heightVariance;

    ctx.beginPath();
    ctx.moveTo(x, GameState.height);
    ctx.quadraticCurveTo(
      x + Math.sin(time + index) * 10,
      GameState.height - height / 2,
      x + Math.sin(time * 1.2 + index) * 8,
      GameState.height - height
    );
    ctx.stroke();
  },

  renderOceanEffects(ctx) {
    this.renderWaterDroplets(ctx);
    this.renderWakeTrails(ctx);
  },

  renderWaterDroplets(ctx) {
    ParticleSystem.activeWaterDroplets.forEach(drop => {
      if (!drop) return;
      this.drawWaterDroplet(ctx, drop);
    });
  },

  drawWaterDroplet(ctx, drop) {
    ctx.save();
    ctx.globalAlpha = Utils.clamp(drop.alpha || 0, 0, 1);

    // Main droplet
    ctx.fillStyle = 'rgba(173,216,230,0.8)';
    ctx.beginPath();
    ctx.arc(drop.x, drop.y, Utils.clamp(drop.size || 2, 1, 8), 0, Math.PI * 2);
    ctx.fill();

    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    const highlightSize = (drop.size || 2) * 0.4;
    const highlightOffset = (drop.size || 2) * 0.3;
    ctx.beginPath();
    ctx.arc(drop.x - highlightOffset, drop.y - highlightOffset, highlightSize, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  },

  renderWakeTrails(ctx) {
    this.renderWakeTrail(ctx, Player.wakeTrail, 'rgba(255,255,255,0.4)');

    GameObjects.obstacles.forEach(obstacle => {
      if (obstacle && obstacle.wakeTrail) {
        this.renderWakeTrail(ctx, obstacle.wakeTrail, 'rgba(50,50,50,0.3)');
      }
    });
  },

  renderWakeTrail(ctx, trail, color) {
    if (!trail || trail.length < 2) return;

    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';

    this.drawWakeTrailPath(ctx, trail);
    ctx.stroke();
    ctx.restore();
  },

  drawWakeTrailPath(ctx, trail) {
    ctx.beginPath();
    let moveToSet = false;
    
    for (let i = 0; i < trail.length - 1; i++) {
      const wake = trail[i];
      if (!wake) continue;
      
      const WAKE_FADE_TIME = 2;
      const alpha = Utils.clamp(1 - (wake.age || 0) / WAKE_FADE_TIME, 0, 1);

      ctx.save();
      ctx.globalAlpha = alpha;

      if (!moveToSet) {
        ctx.moveTo(wake.x, wake.y);
        moveToSet = true;
      } else {
        ctx.lineTo(wake.x, wake.y);
      }

      ctx.restore();
    }
  },

  renderPlayer(ctx) {
    const playerY = Player.y + (Player.bobOffset || 0);
    this.drawPlayerShip(ctx, Player.x, playerY, Player.width, Player.height);
  },

  renderObstacles(ctx) {
    GameObjects.obstacles.forEach(obstacle => {
      if (!obstacle) return;
      this.updateObstacleRenderPosition(obstacle);
      this.drawEnemyShip(ctx, obstacle);
    });
  },

  updateObstacleRenderPosition(obstacle) {
    const BOBBING_AMPLITUDE = 2;
    const bobbing = Utils.safeMathOperation(() => 
      Math.sin(GameState.oceanTime * 2 + obstacle.x * 0.01) * BOBBING_AMPLITUDE, 0
    );
    obstacle.renderY = obstacle.y + bobbing;
  },

  renderItems(ctx) {
    GameObjects.items.forEach(item => {
      if (!item) return;
      const totalBobOffset = this.calculateItemBobOffset(item);
      this.drawItem(ctx, item, totalBobOffset);
    });
  },

  calculateItemBobOffset(item) {
    const ITEM_BOB_AMPLITUDE = 4;
    const WATER_BOB_AMPLITUDE = 1.5;
    
    const itemBob = Utils.safeMathOperation(() => 
      Math.sin((item.sparkleTime || 0) * 3 + (item.bobOffset || 0)) * ITEM_BOB_AMPLITUDE, 0
    );
    const waterBob = Utils.safeMathOperation(() => 
      Math.sin(GameState.oceanTime * 2.5 + item.x * 0.02) * WATER_BOB_AMPLITUDE, 0
    );
    
    return itemBob + waterBob;
  },

  renderParticles(ctx) {
    ParticleSystem.activeParticles.forEach(particle => {
      if (!particle) return;
      this.drawParticle(ctx, particle);
    });
  },

  drawParticle(ctx, particle) {
    ctx.save();
    ctx.globalAlpha = Utils.clamp(particle.alpha || 0, 0, 1);
    ctx.fillStyle = particle.color || '#ffffff';
    
    const size = Utils.clamp(particle.size || 2, 1, 8);
    const halfSize = size / 2;
    ctx.fillRect(particle.x - halfSize, particle.y - halfSize, size, size);
    ctx.restore();
  },

  drawPlayerShip(ctx, x, y, width, height) {
    ctx.save();
    ctx.translate(x + width / 2, y + height / 2);

    this.drawPlayerHull(ctx, width, height);
    this.drawPlayerDeckDetails(ctx, width, height);
    this.drawPlayerMast(ctx, height);
    this.drawPlayerSails(ctx, width, height);
    this.drawPlayerWake(ctx, width, height);
    this.drawPlayerDamageIndicators(ctx, width, height);

    ctx.restore();
  },

  drawPlayerHull(ctx, width, height) {
    const HULL_COLOR_THRESHOLDS = [75, 50, 25];
    const HULL_COLORS = ['#f2f6ff', '#f0f0e0', '#e8e0d0', '#d0c0b0'];
    
    const colorIndex = HULL_COLOR_THRESHOLDS.findIndex(threshold => Player.hull > threshold);
    const hullColor = HULL_COLORS[colorIndex === -1 ? HULL_COLORS.length - 1 : colorIndex];

    ctx.fillStyle = hullColor;
    ctx.beginPath();
    ctx.moveTo(0, -height * 0.55);
    ctx.quadraticCurveTo(width * 0.45, -height * 0.25, width * 0.38, height * 0.40);
    ctx.lineTo(-width * 0.38, height * 0.40);
    ctx.quadraticCurveTo(-width * 0.45, -height * 0.25, 0, -height * 0.55);
    ctx.closePath();
    ctx.fill();
  },

  drawPlayerDeckDetails(ctx, width, height) {
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-width * 0.32, height * 0.30);
    ctx.lineTo(width * 0.32, height * 0.30);
    ctx.stroke();
  },

  drawPlayerMast(ctx, height) {
    const MAST_WIDTH = 4;
    ctx.fillStyle = '#c9d3e7';
    ctx.fillRect(-MAST_WIDTH / 2, -height * 0.48, MAST_WIDTH, height * 0.78);
  },

  drawPlayerSails(ctx, width, height) {
    const sailAlpha = Utils.clamp(0.85 * Math.max(0.25, Player.sails / 100), 0.2, 1);
    const windEffect = Utils.safeMathOperation(() => Math.sin(GameState.oceanTime * 3) * 2, 0);

    ctx.fillStyle = `rgba(255,255,255,${sailAlpha})`;

    // Main sail
    this.drawMainSail(ctx, width, height, windEffect);
    // Jib sail
    this.drawJibSail(ctx, width, height, windEffect);
  },

  drawMainSail(ctx, width, height, windEffect) {
    ctx.beginPath();
    ctx.moveTo(0, -height * 0.45);
    ctx.quadraticCurveTo(width * 0.30 + windEffect, -height * 0.25, width * 0.30, -height * 0.05);
    ctx.lineTo(0, -height * 0.05);
    ctx.closePath();
    ctx.fill();
  },

  drawJibSail(ctx, width, height, windEffect) {
    ctx.beginPath();
    ctx.moveTo(0, -height * 0.35);
    ctx.quadraticCurveTo(-width * 0.28 - windEffect * 0.5, -height * 0.15, -width * 0.28, 0);
    ctx.lineTo(0, 0);
    ctx.closePath();
    ctx.fill();
  },

  drawPlayerWake(ctx, width, height) {
    const baseAlpha = CONFIG.EFFECTS.WAKE_ALPHA;
    const waveVariation = Math.sin(GameState.oceanTime * 4) * 0.2;
    const wakeAlpha = Utils.clamp(baseAlpha + waveVariation, 0.4, 0.8);

    // Primary wake
    ctx.fillStyle = `rgba(255,255,255,${wakeAlpha})`;
    ctx.fillRect(-width * 0.22, height * 0.45, width * 0.44, 3);

    // Secondary wakes
    ctx.fillStyle = `rgba(255,255,255,${wakeAlpha * 0.7})`;
    ctx.fillRect(-width * 0.16, height * 0.50, width * 0.32, 2);
    ctx.fillRect(-width * 0.10, height * 0.55, width * 0.20, 1);
  },

  drawPlayerDamageIndicators(ctx, width, height) {
    const CRITICAL_HULL = 25;
    const DAMAGED_HULL = 50;
    
    if (Player.hull < DAMAGED_HULL) {
      ctx.fillStyle = Player.hull < CRITICAL_HULL ? '#ff3333' : '#ff9900';
      const damageCount = Player.hull < CRITICAL_HULL ? 4 : 2;
      
      for (let i = 0; i < damageCount; i++) {
        const dx = (Math.random() - 0.5) * width * 0.6;
        const dy = (Math.random() - 0.5) * height * 0.4;
        const DAMAGE_SIZE = 4;
        ctx.fillRect(dx - DAMAGE_SIZE / 2, dy - DAMAGE_SIZE / 2, DAMAGE_SIZE, DAMAGE_SIZE);
      }
    }
  },

  drawEnemyShip(ctx, enemy) {
    const renderY = enemy.renderY || enemy.y;

    ctx.save();
    ctx.translate(enemy.x + enemy.width / 2, renderY + enemy.height / 2);

    this.drawEnemyHull(ctx, enemy);
    this.drawEnemyReflection(ctx, enemy);
    this.drawEnemyDetails(ctx, enemy);

    ctx.restore();
  },

  drawEnemyHull(ctx, enemy) {
    const ENEMY_HULL_COLOR = '#0b0b0b';
    
    ctx.fillStyle = ENEMY_HULL_COLOR;
    ctx.beginPath();
    ctx.moveTo(0, enemy.height * 0.50);
    ctx.quadraticCurveTo(enemy.width * 0.48, enemy.height * 0.18, enemy.width * 0.36, -enemy.height * 0.42);
    ctx.lineTo(-enemy.width * 0.36, -enemy.height * 0.42);
    ctx.quadraticCurveTo(-enemy.width * 0.48, enemy.height * 0.18, 0, enemy.height * 0.50);
    ctx.closePath();
    ctx.fill();
  },

  drawEnemyReflection(ctx, enemy) {
    if (PerformanceMonitor.qualityLevel === 'low') return;

    ctx.save();
    ctx.globalAlpha = CONFIG.EFFECTS.WATER_REFLECTION_ALPHA;
    ctx.fillStyle = '#0b0b0b';
    ctx.scale(1, -0.2);
    ctx.translate(0, -enemy.height * 1.5);
    
    ctx.beginPath();
    ctx.moveTo(0, enemy.height * 0.50);
    ctx.quadraticCurveTo(enemy.width * 0.48, enemy.height * 0.18, enemy.width * 0.36, -enemy.height * 0.42);
    ctx.lineTo(-enemy.width * 0.36, -enemy.height * 0.42);
    ctx.quadraticCurveTo(-enemy.width * 0.48, enemy.height * 0.18, 0, enemy.height * 0.50);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
  },

  drawEnemyDetails(ctx, enemy) {
    // Deck
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(-enemy.width * 0.16, -enemy.height * 0.18, enemy.width * 0.32, enemy.height * 0.18);

    // Mast
    ctx.fillStyle = '#0d0d0d';
    const MAST_WIDTH = 6;
    ctx.fillRect(-MAST_WIDTH / 2, -enemy.height * 0.10, MAST_WIDTH, enemy.height * 0.20);

    // Wake
    ctx.fillStyle = 'rgba(50,50,50,0.4)';
    ctx.fillRect(-enemy.width * 0.2, enemy.height * 0.45, enemy.width * 0.4, 2);
  },

  drawItem(ctx, item, bobOffset) {
    ctx.save();
    ctx.translate(item.x + item.width / 2, item.y + item.height / 2 + (bobOffset || 0));

    if (PerformanceMonitor.qualityLevel === 'high') {
      this.drawItemReflection(ctx, item);
    }

    this.drawMainItem(ctx, item);
    this.drawItemSparkle(ctx, item);

    ctx.restore();
  },

  drawItemReflection(ctx, item) {
    const REFLECTION_ALPHA = 0.3;
    const REFLECTION_SCALE = 0.4;
    
    ctx.save();
    ctx.globalAlpha = REFLECTION_ALPHA;
    ctx.scale(1, -REFLECTION_SCALE);
    ctx.translate(0, item.height);

    const primaryColor = item.type === 'fuel' ? '#ff6600' : '#228b22';
    ctx.fillStyle = primaryColor;
    ctx.fillRect(-item.width / 2, -item.height / 2, item.width, item.height);
    
    ctx.restore();
  },

  drawMainItem(ctx, item) {
    if (item.type === 'fuel') {
      this.drawFuelItem(ctx, item);
    } else {
      this.drawRepairItem(ctx, item);
    }
  },

  drawFuelItem(ctx, item) {
    const PRIMARY_COLOR = '#ff6600';
    const SECONDARY_COLOR = '#ff9900';
    const BORDER_SIZE = 2;
    
    // Outer container
    ctx.fillStyle = PRIMARY_COLOR;
    ctx.fillRect(-item.width / 2, -item.height / 2, item.width, item.height);
    
    // Inner container
    ctx.fillStyle = SECONDARY_COLOR;
    ctx.fillRect(
      -item.width / 2 + BORDER_SIZE, 
      -item.height / 2 + BORDER_SIZE, 
      item.width - BORDER_SIZE * 2, 
      item.height - BORDER_SIZE * 2
    );
    
    // Label
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('F', 0, 4);
  },

  drawRepairItem(ctx, item) {
    const PRIMARY_COLOR = '#228b22';
    const SECONDARY_COLOR = '#32cd32';
    const BORDER_SIZE = 2;
    const CROSS_SIZE = 8;
    
    // Outer container
    ctx.fillStyle = PRIMARY_COLOR;
    ctx.fillRect(-item.width / 2, -item.height / 2, item.width, item.height);
    
    // Inner container
    ctx.fillStyle = SECONDARY_COLOR;
    ctx.fillRect(
      -item.width / 2 + BORDER_SIZE, 
      -item.height / 2 + BORDER_SIZE, 
      item.width - BORDER_SIZE * 2, 
      item.height - BORDER_SIZE * 2
    );
    
    // Cross symbol
    ctx.fillStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-CROSS_SIZE, 0);
    ctx.lineTo(CROSS_SIZE, 0);
    ctx.moveTo(0, -CROSS_SIZE);
    ctx.lineTo(0, CROSS_SIZE);
    ctx.stroke();
  },

  drawItemSparkle(ctx, item) {
    if (PerformanceMonitor.qualityLevel === 'low') return;
    
    const SPARKLE_THRESHOLD = 0.5;
    const sparkleActive = Math.sin((item.sparkleTime || 0) * CONFIG.EFFECTS.ITEM_SPARKLE_FREQUENCY) > SPARKLE_THRESHOLD;
    
    if (!sparkleActive) return;

    // Inner sparkle ring
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, 0, item.width / 2 + 4, 0, Math.PI * 2);
    ctx.stroke();

    // Outer sparkle ring
    ctx.strokeStyle = 'rgba(173,216,230,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, item.height / 2 + 5, item.width / 2 + 8, 0, Math.PI * 2);
    ctx.stroke();
  }
};

/* ============================================================================
 * HUD MANAGER MODULE - Optimized DOM updates
 * ============================================================================ */
const HudManager = {
  lastUpdate: 0,
  updateInterval: 100, // Update every 100ms instead of every frame
  lastValues: {
    distance: -1,
    score: -1,
    hull: -1,
    fuel: -1,
    season: -1
  },

  update() {
    const now = performance.now();
    if (now - this.lastUpdate < this.updateInterval) return;
    
    this.updateGameStats();
    this.updateResourceBars();
    this.updateSeasonIndicator();
    
    this.lastUpdate = now;
  },

  updateGameStats() {
    const distance = Math.max(0, Math.floor(GameState.distance / 1000));
    const score = Math.max(0, Math.floor(GameState.score));

    if (distance !== this.lastValues.distance) {
      const element = GameState.cacheElement('distance');
      if (element) element.textContent = distance + 'km';
      this.lastValues.distance = distance;
    }

    if (score !== this.lastValues.score) {
      const element = GameState.cacheElement('score');
      if (element) element.textContent = score.toLocaleString();
      this.lastValues.score = score;
    }
  },

  updateResourceBars() {
    const hull = Utils.clamp(Math.round(Player.hull), 0, 100);
    const fuel = Utils.clamp(Math.round(Player.fuel), 0, 100);

    if (hull !== this.lastValues.hull) {
      this.updateResourceBar('hull', hull);
      this.lastValues.hull = hull;
    }

    if (fuel !== this.lastValues.fuel) {
      this.updateResourceBar('fuel', fuel);
      this.lastValues.fuel = fuel;
    }
  },

  updateResourceBar(type, value) {
    const percentElement = GameState.cacheElement(type + 'Percent');
    const barElement = GameState.cacheElement(type + 'Bar');

    if (percentElement) percentElement.textContent = value + '%';
    if (barElement) barElement.style.width = value + '%';
  },

  updateSeasonIndicator() {
    if (GameState.season === this.lastValues.season) return;

    const seasonElement = GameState.cacheElement('season');
    if (seasonElement) {
      const seasonIndex = Utils.clamp(GameState.season, 0, CONFIG.SEASONS.NAMES.length - 1);
      seasonElement.textContent = CONFIG.SEASONS.NAMES[seasonIndex];
      seasonElement.className = 'season-indicator ' + CONFIG.SEASONS.CSS_CLASSES[seasonIndex];
    }
    
    this.lastValues.season = GameState.season;
  }
};

/* ============================================================================
 * INPUT MANAGER MODULE
 * ============================================================================ */
const InputManager = {
  keys: {},
  touchState: { left: false, right: false },
  mobileEventListeners: [],

  init() {
    this.setupKeyboardEvents();
    if (GameState.isMobile) {
      this.setupMobileControls();
    }
    this.setupVisibilityHandling();
  },

  setupKeyboardEvents() {
    document.addEventListener('keydown', this.onKeyDown.bind(this));
    document.addEventListener('keyup', this.onKeyUp.bind(this));
  },

  setupVisibilityHandling() {
    document.addEventListener('visibilitychange', this.onVisibilityChange.bind(this));
  },

  onKeyDown(e) {
    this.keys[e.code] = true;
    if (e.code === 'Space') {
      e.preventDefault();
      GameManager.togglePause();
    }
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'KeyA', 'KeyD'].includes(e.code)) {
      e.preventDefault();
    }
  },

  onKeyUp(e) {
    this.keys[e.code] = false;
  },

  onVisibilityChange() {
    if (document.hidden && GameState.running && !GameState.paused) {
      GameManager.togglePause();
    }
  },

  setupMobileControls() {
    this.cleanupMobileControls();
    
    const leftArea = GameState.cacheElement('mobileLeftArea');
    const rightArea = GameState.cacheElement('mobileRightArea');
    
    if (!leftArea || !rightArea) return;

    this.attachMobileTouchEvents(leftArea, rightArea);
  },

  attachMobileTouchEvents(leftArea, rightArea) {
    const eventOptions = { passive: false };
    
    const handlers = {
      leftTouchStart: (e) => { e.preventDefault(); this.touchState.left = true; },
      leftTouchEnd: (e) => { e.preventDefault(); this.touchState.left = false; },
      rightTouchStart: (e) => { e.preventDefault(); this.touchState.right = true; },
      rightTouchEnd: (e) => { e.preventDefault(); this.touchState.right = false; },
      preventMove: (e) => e.preventDefault()
    };

    leftArea.addEventListener('touchstart', handlers.leftTouchStart, eventOptions);
    leftArea.addEventListener('touchend', handlers.leftTouchEnd, eventOptions);
    rightArea.addEventListener('touchstart', handlers.rightTouchStart, eventOptions);
    rightArea.addEventListener('touchend', handlers.rightTouchEnd, eventOptions);
    document.addEventListener('touchmove', handlers.preventMove, eventOptions);

    this.mobileEventListeners = [
      { element: leftArea, event: 'touchstart', handler: handlers.leftTouchStart },
      { element: leftArea, event: 'touchend', handler: handlers.leftTouchEnd },
      { element: rightArea, event: 'touchstart', handler: handlers.rightTouchStart },
      { element: rightArea, event: 'touchend', handler: handlers.rightTouchEnd },
      { element: document, event: 'touchmove', handler: handlers.preventMove }
    ];
  },

  cleanupMobileControls() {
    this.mobileEventListeners.forEach(({ element, event, handler }) => {
      try {
        element.removeEventListener(event, handler);
      } catch (e) {
        console.warn('Event listener cleanup failed:', e);
      }
    });
    this.mobileEventListeners = [];
    this.touchState = { left: false, right: false };
  },

  cleanup() {
    document.removeEventListener('keydown', this.onKeyDown.bind(this));
    document.removeEventListener('keyup', this.onKeyUp.bind(this));
    document.removeEventListener('visibilitychange', this.onVisibilityChange.bind(this));
    this.cleanupMobileControls();
    this.keys = {};
  }
};

/* ============================================================================
 * CANVAS MANAGER MODULE
 * ============================================================================ */
const CanvasManager = {
  init() {
    GameState.canvas = document.getElementById('gameCanvas');
    if (!GameState.canvas) throw new Error('Canvas not found');
    
    const contextOptions = { alpha: false, desynchronized: true };
    GameState.ctx = GameState.canvas.getContext('2d', contextOptions);
    if (!GameState.ctx) throw new Error('Canvas context not available');
    
    this.resizeCanvas();
    this.setupEventListeners();
  },

  setupEventListeners() {
    window.addEventListener('resize', this.resizeCanvas.bind(this));
    window.addEventListener('orientationchange', this.handleOrientationChange.bind(this));
  },

  resizeCanvas() {
    const { innerWidth: viewportWidth, innerHeight: viewportHeight } = window;

    GameState.width = Math.max(CONFIG.CANVAS.MIN_WIDTH, viewportWidth);
    GameState.height = Math.max(CONFIG.CANVAS.MIN_HEIGHT, viewportHeight);

    if (!GameState.canvas || !GameState.ctx) return;

    this.updateCanvasSize(viewportWidth, viewportHeight);
    this.updateCanvasContext();

    if (GameState.running) {
      Player.repositionOnResize();
    }
  },

  updateCanvasSize(viewportWidth, viewportHeight) {
    GameState.canvas.style.width = viewportWidth + 'px';
    GameState.canvas.style.height = viewportHeight + 'px';

    const dpr = GameState.devicePixelRatio;
    GameState.canvas.width = viewportWidth * dpr;
    GameState.canvas.height = viewportHeight * dpr;
  },

  updateCanvasContext() {
    GameState.ctx.setTransform(1, 0, 0, 1, 0, 0);
    GameState.ctx.scale(GameState.devicePixelRatio, GameState.devicePixelRatio);

    GameState.width = window.innerWidth;
    GameState.height = window.innerHeight;
  },

  handleOrientationChange() {
    const ORIENTATION_CHANGE_DELAY = 100;
    setTimeout(() => this.resizeCanvas(), ORIENTATION_CHANGE_DELAY);
  },

  cleanup() {
    window.removeEventListener('resize', this.resizeCanvas.bind(this));
    window.removeEventListener('orientationchange', this.handleOrientationChange.bind(this));
  }
};

/* ============================================================================
 * GAME MANAGER MODULE - Main game controller
 * ============================================================================ */
const GameManager = {
  init() {
    try {
      if (!BrowserCompatibility.checkSupport()) {
        BrowserCompatibility.showFallbackMessage();
        return;
      }

      BrowserCompatibility.setupPolyfills();
      this.initializeModules();
      this.setupUI();
    } catch (e) {
      console.error('Game initialization failed:', e);
      this.showError('Failed to initialize game');
    }
  },

  initializeModules() {
    AudioManager.init();
    CanvasManager.init();
    InputManager.init();
    PerformanceMonitor.init();
  },

  setupUI() {
    if (GameState.isMobile) {
      this.updateControlsText();
    }
  },

  updateControlsText() {
    const controlsText = document.querySelector('.controls');
    if (controlsText) {
      controlsText.innerHTML = 'Touch left/right sides of screen to steer • Touch ☰ to pause<br><small>A/D keys and arrows also available</small>';
    }
  },

  startGame() {
    try {
      AudioManager.init();
      this.showGameUI();
      this.initGame();
    } catch (e) {
      console.error('Game start failed:', e);
      this.returnToMenu();
    }
  },

  showGameUI() {
    const elementsToShow = [
      { id: 'gameCanvas', display: 'block' },
      { id: 'hud', display: 'flex' },
      { id: 'pauseBtn', display: 'block' }
    ];

    const elementsToHide = [
      { id: 'menuScreen', display: 'none' }
    ];

    this.updateElementVisibility(elementsToShow, elementsToHide);

    if (GameState.isMobile) {
      this.showMobileControls();
    }
  },

  showMobileControls() {
    const mobileElements = ['mobileLeftArea', 'mobileRightArea'];
    mobileElements.forEach(id => {
      const element = GameState.cacheElement(id);
      if (element) element.style.display = 'block';
    });
    InputManager.setupMobileControls();
  },

  updateElementVisibility(toShow, toHide) {
    [...toShow, ...toHide].forEach(({ id, display }) => {
      const element = document.getElementById(id);
      if (element) element.style.display = display;
    });
  },

  initGame() {
    try {
      this.resetGameState();
      this.positionPlayer();
      this.clearGameObjects();
      this.startGameLoop();
    } catch (e) {
      console.error('Game initialization failed:', e);
      this.returnToMenu();
    }
  },

  resetGameState() {
    GameState.reset();
    Player.reset();
    InputManager.keys = {};
  },

  positionPlayer() {
    Player.setInitialPosition();
  },

  clearGameObjects() {
    GameObjects.clear();
    ParticleSystem.clear();
  },

  startGameLoop() {
    GameState.running = true;
    GameState.lastTime = performance.now();
    requestAnimationFrame(this.gameLoop.bind(this));
  },

  gameLoop(timestamp) {
    if (!GameState.running) return;

    try {
      const deltaTime = this.calculateDeltaTime(timestamp);
      PerformanceMonitor.update(deltaTime);

      if (!GameState.paused) {
        this.update(deltaTime);
      }
      
      Renderer.render();
      requestAnimationFrame(this.gameLoop.bind(this));
    } catch (e) {
      console.error('Game loop error:', e);
      this.endGame();
    }
  },

  calculateDeltaTime(timestamp) {
    const rawDelta = (timestamp - GameState.lastTime) / 1000;
    GameState.lastTime = timestamp;
    return Utils.clamp(rawDelta, CONFIG.GAME.MIN_DELTA_TIME, CONFIG.GAME.MAX_DELTA_TIME);
  },

  update(deltaTime) {
    this.updateGameTime(deltaTime);
    this.updateGameProgress(deltaTime);
    this.updateGameSystems(deltaTime);
    this.checkGameEndConditions();
  },

  updateGameTime(deltaTime) {
    GameState.oceanTime += deltaTime;
  },

  updateGameProgress(deltaTime) {
    const sailEfficiency = Utils.clamp(Player.sails / 100, CONFIG.PLAYER.MIN_EFFICIENCY, 1);
    const DISTANCE_MULTIPLIER = 120;
    GameState.distance += Utils.safeMathOperation(() => 
      DISTANCE_MULTIPLIER * deltaTime * sailEfficiency, 0
    );
  },

  updateGameSystems(deltaTime) {
    SeasonSystem.update();
    Player.update(deltaTime, InputManager.keys, InputManager.touchState);
    GameObjects.update(deltaTime);
    ParticleSystem.update(deltaTime);
    CollisionSystem.checkCollisions();
    this.updateGameplayElements(deltaTime);
    this.updateScore();
    HudManager.update();
  },

  updateGameplayElements(deltaTime) {
    if (GameState.shakeTime > 0) {
      GameState.shakeTime = Math.max(0, GameState.shakeTime - deltaTime);
    }

    if (GameState.combo > 1) {
      GameState.comboTimer = Math.max(0, GameState.comboTimer - deltaTime);
      if (GameState.comboTimer <= 0) {
        this.resetCombo();
      }
    }
  },

  resetCombo() {
    GameState.combo = 0;
    const indicator = GameState.cacheElement('comboIndicator');
    if (indicator) indicator.style.display = 'none';
  },

  updateScore() {
    const comboMultiplier = GameState.combo > 1 ? 
      1 + (GameState.combo - 1) * CONFIG.COMBO.SCORE_MULTIPLIER : 1;
    const seasonMultiplier = CONFIG.SEASONS.SCORE_MULTIPLIERS[GameState.season] || 1;
    
    GameState.score = Math.max(0, Math.floor(GameState.distance * seasonMultiplier * comboMultiplier));
  },

  checkGameEndConditions() {
    if (Player.hull <= 0 || Player.fuel <= 0) {
      this.endGame();
    }
  },

  togglePause() {
    GameState.paused = !GameState.paused;
    const pauseScreen = GameState.cacheElement('pauseScreen');
    if (pauseScreen) {
      pauseScreen.style.display = GameState.paused ? 'flex' : 'none';
    }
  },

  restartGame() {
    this.cleanup();
    this.hideScreens(['gameOverScreen', 'pauseScreen']);
    this.startGame();
  },

  returnToMenu() {
    this.cleanup();
    this.hideGameElements();
    this.showMenuScreen();
  },

  hideScreens(screenIds) {
    screenIds.forEach(id => {
      const element = GameState.cacheElement(id);
      if (element) element.style.display = 'none';
    });
  },

  hideGameElements() {
    const elementsToHide = [
      'gameOverScreen', 'pauseScreen', 'gameCanvas', 'hud', 
      'pauseBtn', 'comboIndicator', 'mobileLeftArea', 'mobileRightArea'
    ];
    elementsToHide.forEach(id => {
      const element = GameState.cacheElement(id);
      if (element) element.style.display = 'none';
    });
  },

  showMenuScreen() {
    const menuScreen = GameState.cacheElement('menuScreen');
    if (menuScreen) menuScreen.style.display = 'flex';
  },

  endGame() {
    this.cleanup();
    this.playGameOverSounds();
    this.displayGameOverScreen();
  },

  playGameOverSounds() {
    const GAME_OVER_SOUNDS = [
      { freq: 220, duration: 420, delay: 0 },
      { freq: 160, duration: 420, delay: 200 },
      { freq: 110, duration: 620, delay: 420 }
    ];

    GAME_OVER_SOUNDS.forEach(({ freq, duration, delay }) => {
      setTimeout(() => AudioManager.playTone(freq, duration, 'sawtooth'), delay);
    });
  },

  displayGameOverScreen() {
    const gameStats = this.calculateFinalStats();
    this.updateGameOverDisplay(gameStats);
    
    const gameOverScreen = GameState.cacheElement('gameOverScreen');
    if (gameOverScreen) gameOverScreen.style.display = 'flex';
  },

  calculateFinalStats() {
    const distance = Math.max(0, Math.floor(GameState.distance / 1000));
    const score = Math.max(0, Math.floor(GameState.score));
    const seasonIndex = Utils.clamp(GameState.season, 0, CONFIG.SEASONS.NAMES.length - 1);
    
    return {
      distance: distance + ' km',
      score: score.toLocaleString(),
      season: CONFIG.SEASONS.NAMES[seasonIndex]
    };
  },

  updateGameOverDisplay({ distance, score, season }) {
    const updates = [
      { id: 'finalDistance', value: distance },
      { id: 'finalScore', value: score },
      { id: 'finalSeason', value: season }
    ];

    updates.forEach(({ id, value }) => {
      const element = GameState.cacheElement(id);
      if (element) element.textContent = value;
    });
  },

  cleanup() {
    GameState.running = false;
    
    InputManager.cleanup();
    CanvasManager.cleanup();
    AudioManager.cleanup();
    
    GameObjects.clear();
    ParticleSystem.clear();
    
    if (Player.wakeTrail) {
      Player.wakeTrail.forEach(node => ObjectPool.releaseWakeNode(node));
      Player.wakeTrail.length = 0;
    }
  },

  showError(message) {
    console.error(message);
    // Could show error UI here
  }
};

/* ============================================================================
 * INITIALIZATION
 * ============================================================================ */
window.addEventListener('load', () => {
  try {
    GameManager.init();
  } catch (e) {
    console.error('Page load initialization failed:', e);
    
    // Show fallback message if main initialization fails
    const fallback = document.getElementById('fallbackMessage');
    const menu = document.getElementById('menuScreen');
    if (fallback && menu) {
      fallback.style.display = 'flex';
      menu.style.display = 'none';
    }
  }
});

// Prevent context menu on right click for better mobile experience
document.addEventListener('contextmenu', e => e.preventDefault());

// Handle page unload cleanup
window.addEventListener('beforeunload', () => {
  try {
    if (GameManager && typeof GameManager.cleanup === 'function') {
      GameManager.cleanup();
    }
  } catch (e) {
    console.warn('Cleanup failed during page unload:', e);
  }
});
</script>
</body>
</html>
